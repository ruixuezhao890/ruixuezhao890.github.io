[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT-0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的时间，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos"]}]