[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的事件，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_1/","content":"VX.01 宏调控：条件编译实现内核模块化设计前言在正式开始介绍我的项目之前我先补充这个工程的一些信息。我是使用platformio插件进行开发的，编译工具使用的是gcc。可能有人会问这个插件不是用来开发arduino的嘛？有些片面了，arduino只是一个框架，其实也支持cmsis和cubemx等框架的开发，在这个工程中我选择的就是cubemx的框架开发，因为arduino框架封装的太多层，开发操作系统必定需要触及一些底层的函数。使用cubemx框架在这个插件下的开发体验是和早些年的标准库一样的体验，没有软件来生成初始化代码，都需要自己手动初始化。这对我而言无伤大雅，后续会移植到cubemx生成的工程下，现在的重点是方便编写内核，而不是开发。至于keil5，编译器不同若是有时间会实现对应的接口文件。在这个文章中只分析设计想法，具体实现再GitHub仓库中存有代码 链接：https://github.com/ruixuezhao890/vortexRT，当然一部分重要的函数具体实现我会放在文章里。\n宏调控设计：三层配置体系操作系统一般的做法都是使用宏来配置内核的代码是否加入到编译的过程之中。这个内核也不例外，我是用三层配置体系来控制内核代码的编译分支，下面一一介绍。\n1.1 核心配置宏：必定选择\n此类宏对与内核来说是不可或缺的。如果缺少会导致出现二义性，导致编译器不知如何进行正确的编译，所以为了避免这种情况，采取了一些措施，如下：\n#ifndef vortexRT_PRIORITY_ORDER#error &quot;Error: Config macro vortexRT_PRIORITY_ORDER must be defined!&quot;#endif#if (vortexRT_PRIORITY_ORDER &lt; 0) || (vortexRT_PRIORITY_ORDER &gt; 1)#error &quot;Error: vortexRT_PRIORITY_ORDER must have values 0 or 1 only!&quot;#endif\n第一个判断的意思是vortexRT_PRIORITY_ORDER宏如果未定义，编译器会出现错误提醒，提醒的正是#error后面带的信息。 第二个判断的意思是检测vortexRT_PRIORITY_ORDER宏的取值范围如果不是0或1，编译器也会发出警告。\n通过这种方法，确保了宏必定会被定义并且也确保了值的正确，宏正确的实现了开关的效果。\n1.2功能可选宏：自由选择\n此类宏可以自由选择是否定义，如果没有定义则会使用默认值来进行编译控制，同样对宏的取值范围做了约束。具体如下图：\n#ifndef vortexRT_USER_DEFINED_CRITSECT_ENABLE#define vortexRT_USER_DEFINED_CRITSECT_ENABLE  0#endif#if (vortexRT_USER_DEFINED_CRITSECT_ENABLE &lt; 0) || (vortexRT_USER_DEFINED_CRITSECT_ENABLE &gt; 1)#error &quot;Error: vortexRT_USER_DEFINED_CRITSECT_ENABLE must have values 0 or 1 only!&quot;#endif\n上面的代码是控制是否使用用户自定义的临界区的宏，如果未定义则默认为0，所以一般是使用工程能自带的进入临界区的代码，如有特殊需要则可以使用这个宏来更改。取值前面已经说过不再赘述\n1.3调试宏与扩展宏：特殊功能的开关\nvortexRT_DEBUG_ENABLE: 调试模式开关vortexRT_PROCESS_RESTART_ENABLE: 进程重启功能开关类似上面这两种宏，拥有特殊功能方便使用者对内核的操作\n优先级设置可以设置优先级的高低顺序，以freeRTOS为例子，优先级数字越大，优先级越高。我希望这个内核可以控制优先级顺序通过宏vortexRT_PRIORITY_ORDER来控制到底是数字越大优先级越高还是反之。通过宏vortexRT_PROCESS_COUNT来控制线程数量，最大不能超过31，在这个范围内0-31任意多个线程可随意设定，总共最多32个线程。vortexRT_PRIORITY_ORDER为1时优先级数字越大，优先级越高，为0则反之。如下图\n#if vortexRT_PRIORITY_ORDER == 0        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        ...        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif            prIDLE#else   // vortexRT_PRIORITY_ORDER == 1    enum TPriority &#123;            prIDLE,        #if vortexRT_PROCESS_COUNT   &gt; 30            pr30,        #endif        ...        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0        #endif        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif    &#125;;#endif //vortexRT_PRIORITY_ORDER\n\n为了节省内存，还依照不同的最大线程个数，来控制不同的类型数据。\n#if vortexRT_PROCESS_COUNT &lt; 8    typedef uint_fast8_t TProcessMap;#elif vortexRT_PROCESS_COUNT &lt; 16    typedef uint_fast16_t TProcessMap;#else    typedef uint_fast32_t TProcessMap;#endif\n\n任务状态枚举定义enum TProcessStartState  &#123;      pssRunning,      pssSuspended  &#125;;\n相比与freeRTOS的就绪态、运行态、阻塞态和挂起态，本项目的却只有两种状态，为什么呢？\n仅设计运行(pssRunning)和挂起(pssSuspended)两种初始状态，这种精简设计针对嵌入式场景优化：运行状态直接进入调度队列，挂起状态需手动唤醒。牺牲了状态复杂度换取更少的内存占用和更高确定性，适合资源严格受限的单片机运行\n完整代码连接：https://github.com/ruixuezhao890/vortexRT/blob/main/core/vortexRT_defs.h\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/22/rtos/vortexRT_2/","content":"VX.02  内核设计：最重要的实现从这章开始进入内核的设计，应该会使用几篇内容来详细阐述是为何这么设计，会先从主要的几个内核类开始介绍，以及这些核心类如何协同工作，介绍完成之后在最后会补充剩余没有说明的函数或者是其余设计。逐步揭示进程管理、内存调度、中断处理等关键模块的设计奥秘，最后通过uml类图展现内核运转的全景视图。这些类都在os_kernel.h中声明\nTKernel类设计细节函数与变量补充// 声明操作系统启动函数，使用C语言链接规范// NORETURN 表示该函数不会返回（通常进入无限循环）// sp: 初始进程的栈指针extern &quot;C&quot; NORETURN void os_start(stack_item_t* sp);// 根据上下文切换方案选择不同的上下文切换函数声明#if vortexRT_CONTEXT_SWITCH_SCHEME == 0    // 方案0：直接上下文切换    // 声明上下文切换函数，使用C语言链接规范    // Curr_SP: 指向当前进程栈指针的指针（用于保存当前上下文）    // Next_SP: 下一个要切换进程的栈指针（用于恢复新上下文）    extern &quot;C&quot; void os_context_switcher(stack_item_t** Curr_SP, stack_item_t* Next_SP);#else    // 方案1：通过钩子函数进行上下文切换    // 声明上下文切换钩子函数，使用C语言链接规范    // sp: 当前栈指针    // 返回: 下一个要切换进程的栈指针    extern &quot;C&quot; stack_item_t* os_context_switch_hook(stack_item_t* sp);#endif // 定义系统中进程的总数，包括空闲进程(idle process)    // vortexRT_PROCESS_COUNT是用户配置的进程数，+1是包含系统空闲进程    const uint_fast8_t PROCESS_COUNT = vortexRT_PROCESS_COUNT + 1;        // 定义栈默认填充模式，用于检测栈溢出    // vortexRT_STACK_PATTERN是用户定义的栈填充值    const stack_item_t STACK_DEFAULT_PATTERN = vortexRT_STACK_PATTERN;        // 前向声明TBaseProcess类，因为后续函数声明中需要使用    class TBaseProcess;        // 设置优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;        // 设置优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;\n\n整体设计思想\n使用微内核架构：采用精简设计，只保留最核心的调度功能，其他的服务，例如：信号量或者互斥锁等作为外围模块支持，而不包含在这个类内。使这个类更为精简减少flash的占用。\n\n优先级调度：基于优先级的抢占式调度，内核不支持同优先级时间片流转，但是时间片流转会使用插件形式自行决定是否使用。最多支持32个优先级抢占MAX_PROCESS_COUNT\n\n中断管理：通过成员变量ISR_NestCount处理中断嵌套的场景，当ISR_NestCount大于0时禁止调度，最大支持255级中断嵌套。\n\n两种调度：两种上下文切换方案，通过宏开关进行选择。值 0 表示在调度器和操作系统中断服务程序（OS ISRs）中使用直接上下文切换，这是主要的方法。值 1 表示第二种上下文切换方式 —— 通过软件中断实现。根据资料显示Cortex-M 端口仅支持软件中断切换方法。\n\n\n类成员详细说明private:    uint_fast8_t CurProcPriority;          // 当前运行进程的优先级    volatile TProcessMap ReadyProcessMap;  // 就绪进程位图(volatile用于多线程/中断环境)    volatile uint_fast8_t ISR_NestCount;   // 中断嵌套计数器    private:    static TBaseProcess* ProcessTable[PROCESS_COUNT]; // 进程表，按优先级索引        #if vortexRT_CONTEXT_SWITCH_SCHEME == 1    volatile uint_fast8_t SchedProcPriority; // 调度进程优先级(方案1专用)    #endif    #if vortexRT_SYSTEM_TICKS_ENABLE == 1    volatile tick_count_t SysTickCount;     // 系统滴答计数器    #endif\n\n关键方法分析构造函数 \nINLINE TKernel()     : CurProcPriority(MAX_PROCESS_COUNT)  // 初始化为无效优先级表示OS未运行    , ReadyProcessMap((1ull &lt;&lt; PROCESS_COUNT) - 1) // 所有进程初始为就绪状态    , ISR_NestCount(0)  // 无中断嵌套&#123;&#125;\n\n进程管理\n// 注册进程到进程表INLINE static void register_process(TBaseProcess* const p);// 设置进程为就绪状态INLINE void set_process_ready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     set_prio_tag(ReadyProcessMap, PrioTag); &#125;// 设置进程为非就绪状态  INLINE void set_process_unready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     clr_prio_tag(ReadyProcessMap, PrioTag); &#125;\n调度器核心\n// 调度器核心实现void sched();// 调度器入口，检查中断嵌套情况INLINE void scheduler() &#123; if(ISR_NestCount) return; else sched(); &#125;// 中断服务例程专用的调度器INLINE void sched_isr();\n系统定时器\n// 系统定时器处理函数INLINE void system_timer();\n\nvortexRT_CONTEXT_SWITCH_SCHEME为1时专用方法介绍\n  #if vortexRT_CONTEXT_SWITCH_SCHEME == 1// 上下文切换完成检查(方案1专用)INLINE bool is_context_switch_done();// 触发上下文切换(方案1专用)INLINE void raise_context_switch() &#123; OS::raise_context_switch(); &#125;#endif\n\n全局单例模式声明。为什么不使用c++的单例模式？\n因为嵌入式系统资源受限制，单例模式在c++的实现会触及到动态内存分配和其他的额外开销对于资源少的单片机可能无法接受。所以直接声明全局变量更加能接受与节省资源。而且单例模式的饿汉模式会让加载时机不够明确带来不确定行，全局变量会在main函数之前进行创建加载，时机明确。在c++中的单例模式使用一个函数进行访问，这增加了程序的执行事件，在内核中会多次调用该实例会造成性能损失。并且内核本就是唯一性的不再需要c++的单例模式来提供唯一实例保障机制\nextern TKernel Kernel;\n\n\n\n设计特点\n高效位图操作：使用位图ReadyProcessMap来管理进程状态，通过位状态来查早最高优先级进程。\nvolatile关键字：关键变量使用该关键字确保多线程&#x2F;中断环境下的正确访问不出现错误。\n通过宏开关支持不同的配置方案更加灵活，适配更多的可能。\n内联函数：简单函数使用内联让编译器对其进行优化，提高执行效率降低性能损失，增加实时性\n\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/23/rtos/vortexRT_3/","content":"VX.03 基础进程实现：并行基石依照查询得到的资料可以知道，操作系统可以分为返回独立栈和不返回独立栈，这两种各有优劣，我选择使用宏定义由用户来选择支持哪一种模式。下面我将分别阐述这两种模式的优点与何时使用哪一种模式。\n\n返回独立栈：返回独立栈例如线程栈、任务栈。独立栈的意思是每个任务或者线程都拥有独立的栈空间，用于保存任务执行时的局部变量和函数调用链还有上下文的信息。它切换任务时，内核会修改线程栈指针（PSP，这个指针是硬件定义的指针）切换到新的任务栈空间，确保任务之间的隔离性。避免任务间栈溢出互相干扰，提高系统稳定性。可根据任务需求灵活分配栈大小（例如FreeRTOS中动态分配堆内存作为任务栈） 高效上下文切换：仅需保存当前任务的寄存器状态到其独立栈中，无需处理其他任务的栈数据。 \n非独立返回栈：所有的任务都共享同一栈空间（主栈MSP），任务切换的时候直接在共享栈中保存和恢复上下文。无需切换栈指针，直接通过压栈和出栈来管理上下文，一般用于裸机程序或者简单的调度系统。可以节省内存，不用给每个任务分配独立栈空间，使用资源受限的单片机，但是任务或者中断嵌套调用可能会导致共享栈溢出，破坏其他任务或者系统数据。\n\n由于是第一次写内核，我选择非独立栈来完成这个设计，但是预留独立栈的接口，通过宏定义来进行选择后面了解更加深入之后发现cortex-M其实也是独立堆栈，只不过是自动管理两个对堆栈的自动切换，所以非独立堆栈是为了给cortex类的单片机使用的，独立堆栈使用来给其他不能自动管理堆栈的单片机用的，例如：msp430。\nTBaseProcess的设计思考整体设计思想TBaseProcess是进程&#x2F;任务管理的基类，采用优先级调度机制支持两种栈配置模式（独立与非独立栈）提供进程生命周期管理的方法，以及提供调试信息与性能分析，通过vortexRT_DEBUG_ENABLE来控制开启还是关闭。\n关键数据结构//向前声明两个类，声明变量的时候要用到，后面的篇章会说明功能  class TKernelAgent;  class TService;protected:        // 数据成员        stack_item_t* StackPointer;    // 当前栈指针        volatile timeout_t Timeout;    // 超时计数器(volatile用于多线程/中断环境)        const TPriority Priority;      // 进程优先级(常量)        #if vortexRT_DEBUG_ENABLE == 1        // 调试相关数据成员        TService* volatile WaitingFor; // 当前等待的服务(可能被中断修改)        const stack_item_t* const StackPool; // 栈池起始地址(常量指针)        const size_t StackSize;        // 栈大小(以stack_item_t为单位)        const char* Name;              // 进程名称        #if SEPARATE_RETURN_STACK == 1 //独立栈启用        const stack_item_t* const RStackPool; // 返回栈池起始地址        const size_t RStackSize;       // 返回栈大小        #endif    #endif // vortexRT_DEBUG_ENABLE        #if vortexRT_PROCESS_RESTART_ENABLE == 1   //默认为0        volatile TProcessMap* WaitingProcessMap; // 等待进程映射表(重启功能)    #endif        #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0 //默认取消挂起 ，之后会在TService中实现挂起恢复操作        static TProcessMap SuspendedProcessMap; // 挂起进程映射表(静态成员)依旧使用位操作来确立是否挂起    #endif\n进程管理的方法介绍主要提供以下的管理方法：\n\nsleep() -顾名思义使得进程状态进入休眠，不再被调度；\nwake_up() -看名字依旧知道，唤醒进程；\nforce_wake_up() -强制唤醒进程；\nis_sleeping()-查看进程是不是休眠状态；\nis_suspended() -查看进程是不是被挂起状态；sleep相当与freertos的delay函数的功能，将进程休眠让出cpu的使用权力，超过时间后自动唤醒，也可以在超时之前使用wake_up进行主动唤醒。force_wake_up强制唤醒，不会确认进程是否处于休眠状态，直接唤醒执行。普通的唤醒是线程安全的不会破坏系统的状态，但是强制唤醒可能会重复唤醒同一个进程并且破坏优先级调度逻辑，导致资源竞争。大部分情况下都建议使用wake_up,少数特殊场景使用强制唤醒，例如：系统初始化进程时，从不可恢复的错误的状态下恢复时，看门狗恢复死锁进程时等。\nreset_controls() -重置进程控制状态 通过宏vortexRT_PROCESS_RESTART_ENABLE来确定是否开启该函数的定义，默认是关闭的\n\n栈管理的两种模式\n非独立返回栈// 参数：        // StackPoolEnd - 栈池结束地址(栈顶)        // pr - 进程优先级        // exec - 进程执行函数指针        // (调试模式下可选参数)        // aStackPool - 栈池起始地址(用于调试)        // name - 进程名称(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                 TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                const char* name = nullptr                #endif                );\n独立返回栈//    参数：// Stack - 数据栈指针(栈顶地址)// RStack - 返回栈指针(栈顶地址) // exec - 进程执行函数指针// (调试模式下可选参数)// StackPool - 数据栈池起始地址(用于调试)// RStackPool - 返回栈池起始地址(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                stack_item_t* RStack,                TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                stack_item_t* aRStackPool,                const char* name = 0                #endif                );\n\n调试的支持说明当调试模式启用时，该类提供 栈的使用情况分析，进程名称标识，和等待服务追踪（WaitingFor 成员变量）\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/25/rtos/vortexRT_4/","content":"VX.04 用户进程创建接口实现：多模式创建线程上一篇说到支持不同的栈模式，所以供系统调用的进程类也要支持不同模式下的正确创建，但是在TBaseProcess中实现对不同的栈模式显得繁琐并且不好维护。所以通过宏开关来选择是栈独立还是非独立实现具体进程的实例化，并且通过继承来复用TBaseProcess中封装好的进程通用操作，减少代码的重复性。通过宏在编译期间就确定避免运行时开销。\nprocess用户调用类实现思路由于非独立栈与独立栈的相差不是很多，这里以非独立栈进行讲解，补充一些独立栈的不同之处不再过多赘述。设计想法：通过编译期间来确定进程的特性。例如：优先级，栈大小，初始化状态。所以设计这个类使用模板参数传递必要参数，在编译期间进行计算与确定。  为了避开动态内存分配，毕竟资源不足的单片机上是不足以支持这种使用方法的，所以使用静态数组管理栈空间，避免运行时内存的分配。分层架构设计继承TBaseProcess复用核心功能，并且派生类只用实现exec()函数即可，这就是线程执行函数。\n最后通过typdef来重命名一个空闲进程，通过全局单例实例化来进行实例化。\n非独立返回栈template&lt;TPriority pr, size_t stk_size, TProcessStartState pss = pssRunning&gt;       class process : public TBaseProcess       &#123;       public:           // 构造函数声明(使用INLINE_PROCESS_CTOR宏定义内联)           // 参数：           // name_str - 进程名称字符串指针(调试模式下使用)           INLINE_PROCESS_CTOR process( const char * name_str = nullptr );           // 进程执行函数声明(必须由派生类实现)           // 使用OS_PROCESS宏定义特殊属性           OS_PROCESS static void exec();       #if vortexRT_PROCESS_RESTART_ENABLE == 1           // 进程终止函数(当启用进程重启功能时有效)           // 用于安全终止并重置进程状态           INLINE void terminate();       #endif              private:           // 进程栈空间数组           // 大小根据模板参数stk_size计算(stack_item_t单位)           stack_item_t Stack[stk_size/sizeof(stack_item_t)];       &#125;;       // 进程模板类构造函数实现       template&lt;TPriority pr, size_t stk_size, TProcessStartState pss&gt;       OS::process&lt;pr, stk_size, pss&gt;::process( const char *           #if vortexRT_DEBUG_ENABLE == 1// 调试模式下使用进程名称           name_str           #endif           ) : TBaseProcess(&amp;Stack[stk_size / sizeof(stack_item_t)]// 栈顶地址                            , pr// 进程优先级                            , reinterpret_cast&lt;void (*)()&gt;(exec)// 执行函数指针转换                         #if vortexRT_DEBUG_ENABLE == 1// 调试模式下使用进程名称                            , Stack// 栈起始地址(调试)                            , name_str// 进程名称(调试)                         #endif                            )                  &#123;           #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0           // 如果进程启动状态为挂起(pssSuspended)           if ( pss == pssSuspended )               // 从全局挂起进程映射表中清除当前优先级标记               clr_prio_tag(SuspendedProcessMap, get_prio_tag(pr));           #endif       &#125;       #if vortexRT_PROCESS_RESTART_ENABLE == 1       // 进程终止函数实现       template&lt;TPriority pr, size_t stk_size, TProcessStartState pss&gt;       void OS::process&lt;pr, stk_size, pss&gt;::terminate()       &#123;           TCritSect cs;// 临界区保护(防止中断干扰)           // 重置进程控制状态(清除等待状态等)           reset_controls();           // 重新初始化栈帧(保持原有执行函数)           init_stack_frame( &amp;Stack[stk_size/sizeof(stack_item_t)]                            , reinterpret_cast&lt;void (*)()&gt;(exec)                         #if vortexRT_DEBUG_ENABLE == 1                             , Stack                         #endif                           );       &#125;       #endif // vortexRT_RESTART_ENABLE   // 定义系统空闲进程类型别名   // 使用最低优先级(prIDLE)和预定义的栈大小       typedef OS::process&lt;OS::prIDLE, vortexRT_IDLE_PROCESS_STACK_SIZE&gt; TIdleProc;\n独立栈的版本// 进程模板类定义(双栈版本)// 模板参数：// pr       - 进程优先级(TPriority枚举类型)// stk_size - 数据栈空间大小(字节数)// rstk_size - 返回栈空间大小(字节数)// pss      - 进程启动状态(默认pssRunning运行状态)template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss = pssRunning&gt;class process : public TBaseProcess &#123;public:    // 构造函数声明(使用INLINE_PROCESS_CTOR宏定义内联)    // 参数：    // name_str - 进程名称字符串指针(调试模式下使用)    INLINE_PROCESS_CTOR process(const char* name_str = 0);    // 进程执行函数声明(必须由派生类实现)    // 使用OS_PROCESS宏定义特殊属性    OS_PROCESS static void exec();#if vortexRT_PROCESS_RESTART_ENABLE == 1    // 进程终止函数(当启用进程重启功能时有效)    // 用于安全终止并重置进程状态    INLINE void terminate();#endifprivate:    // 进程数据栈空间数组    stack_item_t Stack[stk_size/sizeof(stack_item_t)];    // 进程返回栈空间数组    stack_item_t RStack[rstk_size/sizeof(stack_item_t)];&#125;;// 进程模板类构造函数实现template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss&gt;process&lt;pr, stk_size, rstk_size, pss&gt;::process(const char*    #if vortexRT_DEBUG_ENABLE == 1  // 调试模式下使用进程名称    name_str    #endif    ): TBaseProcess(&amp;Stack[stk_size / sizeof(stack_item_t)],  // 数据栈顶地址                   &amp;RStack[rstk_size/sizeof(stack_item_t)],  // 返回栈顶地址                   pr,                                       // 进程优先级                   reinterpret_cast&lt;void (*)()&gt;(exec)         // 执行函数指针转换                #if vortexRT_DEBUG_ENABLE == 1               // 调试模式参数                   , Stack                                   // 数据栈起始地址                   , RStack                                  // 返回栈起始地址                   , name_str                                // 进程名称                #endif                   )&#123;    #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0    // 如果进程启动状态为挂起(pssSuspended)    if (pss == pssSuspended) &#123;        // 从全局挂起进程映射表中清除当前优先级标记        clr_prio_tag(SuspendedProcessMap, get_prio_tag(pr));    &#125;    #endif&#125;#if vortexRT_PROCESS_RESTART_ENABLE == 1// 进程终止函数实现template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss&gt;void OS::process&lt;pr, stk_size, rstk_size, pss&gt;::terminate()&#123;    TCritSect cs;  // 临界区保护(防止中断干扰)    // 重置进程控制状态(清除等待状态等)    reset_controls();    // 重新初始化双栈帧(保持原有执行函数)    init_stack_frame(&amp;Stack[stk_size/sizeof(stack_item_t)],                    &amp;RStack[rstk_size/sizeof(stack_item_t)],                    reinterpret_cast&lt;void (*)()&gt;(exec)                #if vortexRT_DEBUG_ENABLE == 1                    , Stack    // 调试模式下传递数据栈起始地址                    , RStack   // 调试模式下传递返回栈起始地址                #endif                    );&#125;#endif// 定义系统空闲进程类型别名(双栈版本)// 使用最低优先级(prIDLE)和预定义的双栈大小typedef OS::process&lt;OS::prIDLE,                    vortexRT_IDLE_PROCESS_DATA_STACK_SIZE,                   vortexRT_IDLE_PROCESS_RETURN_STACK_SIZE&gt; TIdleProc;\n\n最后通过实例化一个空闲进程\nextern TIdleProc IdleProc;\n\n可能有点疑惑为什么进程中是static来声明的exec函数，学过c++的朋友有疑惑，学习c++的时候学习到的明明是静态成员函数是整个类所共有的一个函数，通过类名来进行访问，无需实例化变量访问也可运行。那么这里的进程类为什么能做到每个进程都是各自独立的exec函数呢。其实学习过模板过后就能明白，模板类在进行模板参数传递的时候，其实依据传递的参数编译器会为这个类再生成一份class类，他们每个进程已经不算是同一个类了，所以static声明的exec函数也自然而然独立了，顺利完成线程隔离的任务。权衡代码膨胀与编写便利过后这种设计是可以接受的。\ninit_stack_frame：初始化进程栈函数详解// 初始化任务栈帧// 参数://   Stack - 栈顶指针(高地址)//   exec - 任务入口函数指针//   StackBegin - (调试模式下)栈起始地址(用于栈填充检查)void OS::TBaseProcess::init_stack_frame(stack_item_t* Stack, void (*exec)()#if vortexRT_DEBUG_ENABLE == 1    , stack_item_t* StackBegin#endif)&#123;    // 根据AAPCS规范要求8字节栈对齐    // 将栈指针向下对齐到8字节边界(清除低3位)    StackPointer = (stack_item_t*)((uintptr_t)Stack &amp; 0xFFFFFFF8UL);    // 初始化栈帧内容(模拟中断发生时的自动压栈)    *(--StackPointer) = 0x01000000UL;      // 初始xPSR寄存器值(Thumb状态)    *(--StackPointer) = reinterpret_cast&lt;stack_item_t&gt;(exec); // 任务入口地址(PC)#if (defined __SOFTFP__)    // 无FPU核心(Cortex-M0/M1等)    // 模拟中断自动保存的寄存器: LR,R12,R3,R2,R1,R0,R11-R4 (共14个寄存器)    StackPointer -= 14;                     #else                       // 有FPU核心(Cortex-M3/M4等)    // 模拟中断自动保存的基本寄存器: LR,R12,R3,R2,R1,R0 (共6个)    StackPointer -= 6;                          *(--StackPointer) = 0xFFFFFFFDUL;      //这个寄存器设置的是返回模式                                           // exc_return值:                                            // - 返回Thread模式                                           // - 不使用FPU上下文                                           // - 使用PSP作为栈指针    StackPointer -= 8;                      // 模拟保存R4-R11寄存器#endif#if vortexRT_DEBUG_ENABLE == 1    // 调试相关处理    *(StackPointer) = reinterpret_cast&lt;stack_item_t&gt;(&amp;DebugInfo); // 强制保留DebugInfo引用    // 用预设模式填充整个栈空间(用于栈溢出检测)    for (stack_item_t* pDst = StackBegin; pDst &lt; StackPointer; pDst++)        *pDst = STACK_DEFAULT_PATTERN;     // 默认使用0xABBA(见vortexRT_STACK_PATTERN定义 os_target.h)#endif&#125;\n任务栈被初始化之后的堆栈布局\n\n为什么需要初始化内存布局？\n\n可以使用上班来类比，我们给一个新员工（进程）安排工位（内存），我们不仅仅要给他桌子（堆栈空间），还要再桌上摆好工作手册（寄存器状态）；电脑开机密码（程序入口）和紧急联系方式（异常返回机制）。\n\n为什么要对齐呢？\n\nArm架构要求栈指针必须八字节对齐，目的是为了性能优化和硬件兼容性。相当于使用空间换时间。举个例：原始栈指针是0x20010003对齐就会抹掉最后的3变成0x20010000。\n\n具体操作分析如下：\n\n首先我们进行八字节对齐之后，模拟硬件的异常压栈，初始化的时候是手动模拟压栈，在运行的时候这一部分是硬件自动完成。第一个寄存器是xPSR寄存器作用是标记CPU状态，我们将其24位初始化为0x01000000UL是为了告诉CPU这是一个“Thumb状态”下的任务。下一个寄存器是R15寄存器，根据arm内核手册知道这是一个pc指针寄存器，所以初始化时我们将进程函数的地址放在这里，让任务醒来的时候在进程函数处运行。之后就是判断是否使用了FPU，如果没有直接往低地址走14个地址，预留出LR,R12,R3-R0,R11-R4的空间，另一种情况就是使用FPU此时先往低地址走6个地址后，第七个低地址时是 EXC_RETURN标记，这里被赋值0xFFFFFFFD： 这是CPU的“暗号”，意思是：“返回线程模式”（普通任务模式）用PSP不要用MSP”（任务用进程栈，内核用主栈），别管FPU寄存器”（节省时间，后面手动处理）就像给CPU贴了张便利贴：“醒来后按这个流程走”。最后如果开启调试模式的话就将后面的空闲堆栈填充为’STACK_DEFAULT_PATTERN’，这里的操作方法和’rtthread’一致。定期扫描模式是否被破坏，在任务调度钩子或空闲任务。\n\n\n\n地址\n值\n意义\n\n\n\n0x200101FC\n0x01000000\nxPSR（CPU状态）\n\n\n0x200101F8\n0x08001234\nPC（任务入口）\n\n\n0x200101F4\n未初始化\nLR（会被EXC_RETURN覆盖）\n\n\n0x200101F0\n未初始化\nR12\n\n\n…\n…\nR3-R0\n\n\n0x200101DC\n0xFFFFFFFD\nEXC_RETURN（魔法值）\n\n\n0x200101D8\n未初始化\nR4\n\n\n…\n…\nR5-R11\n\n\n0x200101B8\n栈顶\n从这里开始动态使用\n\n\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/28/rtos/vortexRT_5/","content":"VX.05 内核代理模式：安全的赋予内核能力TKernelAgent类是内核代理类同时一个工具类，其中的所有方法都是static，主要的功能便是提供对内核关键功能的受控访问接口。封装了内核的核心功能，通过静态方法的方式给其他组件提供内核能力，保证内核内部数据不被直接访问，提高封装性防止被意外更改内核数据。通过protect继承限制只有内核相关的类才能使用这些功能。这个类主要就是为了其他组件能够调用内核服务，又能保持内核内部的实现封装性。\nclass TKernelAgent&#123;    // 获取当前运行进程对象指针    // 通过查询内核的进程表(ProcessTable)获取    INLINE static TBaseProcess * cur_proc() &#123; return Kernel.ProcessTable[cur_proc_priority()]; &#125;protected:    // 构造函数设为protected，限制只有派生类可以实例化    TKernelAgent() &#123; &#125;        // 获取当前运行进程的优先级(只读引用)    INLINE static uint_fast8_t const &amp; cur_proc_priority() &#123; return Kernel.CurProcPriority; &#125;        // 获取就绪进程位图(volatile引用，可能被中断修改)    INLINE static volatile TProcessMap &amp; ready_process_map() &#123; return Kernel.ReadyProcessMap; &#125;        // 获取当前进程的超时计数器(volatile引用)    INLINE static volatile timeout_t &amp; cur_proc_timeout() &#123; return cur_proc()-&gt;Timeout; &#125;        // 触发内核重新调度    INLINE static void reschedule() &#123; Kernel.scheduler(); &#125;    // 设置指定优先级进程为就绪状态    INLINE static void set_process_ready(const uint_fast8_t pr) &#123; Kernel.set_process_ready(pr); &#125;        // 设置指定优先级进程为非就绪状态      INLINE static void set_process_unready(const uint_fast8_t pr) &#123; Kernel.set_process_unready(pr); &#125;#if vortexRT_DEBUG_ENABLE == 1    // 调试模式下获取当前进程等待的服务对象    INLINE static TService * volatile &amp; cur_proc_waiting_for() &#123; return cur_proc()-&gt;WaitingFor; &#125;#endif#if vortexRT_PROCESS_RESTART_ENABLE == 1    // 进程重启功能启用时，获取当前进程的等待映射表    INLINE static volatile TProcessMap * &amp; cur_proc_waiting_map() &#123; return cur_proc()-&gt;WaitingProcessMap; &#125;#endif&#125;;","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/28/rtos/vortexRT_6/","content":"VX.06 系统对外接口现在实现最后的系统对外调用的函数接口，内核文件的设计就已经结束了，下一个篇章实现freeRTOS中的port文件，也就是对于不同的芯片架构和编译器实现不同的接口文件，这才是实现任务调度的关键文件，没有它则无法实现任务调度。\n对外调用接口这一节没啥好说的就是对之前的函数进行了一次封装，直接看代码中的注释能完全理解，不再赘述\n    // 系统运行函数（永不返回）    INLINE NORETURN void run();        // 检查操作系统是否正在运行    INLINE bool os_running();        // 锁定系统定时器（临界区保护）    INLINE void lock_system_timer()    &#123; TCritSect cs; LOCK_SYSTEM_TIMER();   &#125;        // 解锁系统定时器（临界区保护）      INLINE void unlock_system_timer()  &#123; TCritSect cs; UNLOCK_SYSTEM_TIMER(); &#125;        // 进程休眠函数（默认参数0表示无限期休眠）    INLINE void sleep(timeout_t t = 0) &#123; TBaseProcess::sleep(t); &#125;        // 根据优先级获取进程控制块指针    INLINE const TBaseProcess * get_proc(uint_fast8_t Prio) &#123; return Kernel.ProcessTable[Prio]; &#125;        //--------------------------------------------------------------------------#if vortexRT_SYSTEM_TICKS_ENABLE == 1#if vortexRT_SYSTEM_TICKS_ATOMIC == 1    // 原子方式获取系统滴答计数（无锁版本）    INLINE tick_count_t get_tick_count() &#123; return Kernel.SysTickCount; &#125;#else    // 获取系统滴答计数（带临界区保护）    INLINE tick_count_t get_tick_count() &#123; TCritSect cs; return Kernel.SysTickCount; &#125;#endif#endif // vortexRT_SYSTEM_TICKS_ENABLE#if vortexRT_TARGET_IDLE_HOOK_ENABLE == 1    // 目标平台特定的空闲进程钩子函数    void idle_process_target_hook();#endif // vortexRT_TARGET_IDLE_HOOK_ENABLE#if vortexRT_SYSTIMER_HOOK_ENABLE == 1    // 系统定时器钩子函数（必须启用才能使用时间片轮转）    INLINE_SYS_TIMER_HOOK void system_timer_user_hook();#endif // vortexRT_SYSTIMER_HOOK_ENABLE#if vortexRT_CONTEXT_SWITCH_USER_HOOK_ENABLE == 1    // 上下文切换用户钩子函数（用于自定义上下文切换逻辑）    INLINE_CONTEXT_SWITCH_HOOK void context_switch_user_hook();#endif // vortexRT_CONTEXT_SWITCH_USER_HOOK_ENABLE#if vortexRT_IDLE_HOOK_ENABLE == 1    // 空闲进程用户钩子函数（用于自定义空闲任务处理）    void idle_process_user_hook();#endif // vortexRT_IDLE_HOOK_ENABLE\n\n函数具体实现再GitHub仓库：https://github.com/ruixuezhao890/vortexRT函数实现带有注释\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/05/02/rtos/vortexRT_7/","content":"VX.07 target平台函数设计：cortex—gcc平台为例在嵌入式系统开发中，不同处理器架构需要特定的工具链支持文件（包括启动代码、链接脚本、外设寄存器定义等）来实现硬件抽象层的适配。以ARM Cortex-M系列为例，虽然M0&#x2F;M0+&#x2F;M1&#x2F;M3&#x2F;M4&#x2F;M7内核采用统一的Thumb&#x2F;Thumb-2指令集架构，但各子系列在指令集扩展（如M4的DSP指令和可选FPU）、中断控制器（NVIC）配置、内存保护单元（MPU）等方面存在差异。本文基于Cortex-M4硬件平台，通过条件编译和架构抽象层设计，实现了一套兼容Cortex-M0(+)&#x2F;M1&#x2F;M3&#x2F;M4(F)的GCC工具链接口文件，其核心是通过预定义宏（如__ARM_ARCH_6M__&#x2F;7M__）自动识别处理器特性，并动态调整内存布局、中断向量表对齐方式（M0要求8字节对齐而M3&#x2F;M4支持32字节）以及浮点运算调用约定（softfp&#x2F;hard）。\n编译器和目标检查确保编译器是使用GUN编译器并且支持对应芯片的代码编译还要保证编译器的版本足够\n#ifndef __GNUC__#error &quot;This file should only be compiled with GNU C++ Compiler&quot;#endif // __GNUC__#if (!defined __ARM_ARCH_7M__) &amp;&amp; (!defined __ARM_ARCH_7EM__) &amp;&amp; (!defined __ARM_ARCH_6M__)#error &quot;This file must be compiled for ARMv6-M (Cortex-M0(+)), ARMv7-M (Cortex-M3) and ARMv7E-M (Cortex-M4(F)) processors only.&quot;#endif#if (__GNUC__ &lt; 3)#error &quot;This file must be compiled by GCC C/C++ Compiler v3.0 or higher.&quot;#endif\n编译器特定的属性支持通过共定义来确保一些关键字在不同平台下也能正常使用。例如inline\n#ifndef INLINE#define INLINE      __attribute__((__always_inline__)) inline#endif#ifndef NOINLINE#define NOINLINE    __attribute__((__noinline__))#endif#ifndef NORETURN#define NORETURN    __attribute__((__noreturn__))#endiftypedef uint32_t stack_item_t;typedef uint32_t status_reg_t;\nstack_item_t 和 status_reg_t 被定义为 uint32_t 类型，这是为了与ARM Cortex-M架构的32位特性完美匹配。这种设计确保了栈操作的高效性和中断状态处理的精确性，同时保持了代码在不同Cortex-M系列处理器间的可移植性。\n#define OS_PROCESS __attribute__((__noreturn__))#define OS_INTERRUPT extern &quot;C&quot;#define DUMMY_INSTR() __asm__ __volatile__ (&quot;nop&quot;)#define INLINE_PROCESS_CTOR INLINE#define SEPARATE_RETURN_STACK   0#define vortexRT_ISRW_TYPE       TISRW\nOS_PROCESS 标记进程函数永不返回（优化编译器行为）， OS_INTERRUPT 确保中断处理函数使用C语言链接规范（避免C++名称修饰）， DUMMY_INSTR() 提供精确的CPU空操作指令（用于时序控制和同步），而 INLINE_PROCESS_CTOR 则强制进程构造函数内联（提升创建性能）。SEPARATE_RETURN_STACK选择使用非独立栈。vortexRT_ISRW_TYPE用于指定中断服务例程(ISR)的包装器类型。TISRW是一个中断服务历程的包装器，可以实现中断进入时自动增加嵌套计数器和退出时自动检查嵌套技术并触发任务调度，后文会详细说明。\n#define  vortexRT_CONTEXT_SWITCH_SCHEME 1#if (defined __ARM_ARCH_6M__)#define  vortexRT_PRIORITY_ORDER             0#else#define  vortexRT_PRIORITY_ORDER             1#endif\nvortexRT_CONTEXT_SWITCH_SCHEME 这个宏定义指定了vortexRT操作系统在Cortex-M架构下使用软件中断方式进行上下文切换。对于Cortex-M0&#x2F;M0+(ARMv6-M架构)处理器，使用升序优先级(值为0),因为M0系列缺少CLZ(Count Leading Zeros)指令,需要通过查表方式实现优先级查找。对于Cortex-M3&#x2F;M4(ARMv7-M架构)处理器，使用降序优先级(值为1)，可以利用M3&#x2F;M4的CLZ指令高效实现优先级查找，降序排列能获得更好的性能表现。这样设计考虑了两种芯片架构的指令集之间的差异，并且优化系统性能。\n#include &quot;vortexRT_CONFIG.h&quot;#include &quot;vortexRT_TARGET_CFG.h&quot;#include &lt;vortexRT_defs.h&gt;#ifdef vortexRT_USER_DEFINED_STACK_PATTERN#define vortexRT_STACK_PATTERN vortexRT_USER_DEFINED_STACK_PATTERN#else#define vortexRT_STACK_PATTERN 0xABBA#endif\n定义了一个宏 vortexRT_STACK_PATTERN，表示栈内存初始化时的填充值。优先级如下： 如果用户通过 vortexRT_USER_DEFINED_STACK_PATTERN 自定义了值，则优先使用用户的值。如果用户未定义，则使用默认值 0xABBA。\n#define enable_interrupts() __asm__ __volatile__ (&quot;cpsie i&quot;)#define disable_interrupts() __asm__ __volatile__ (&quot;cpsid i&quot;)\n通过正点原子的权威指南得知,上面的两条汇编的功能是开启和关闭中断,也就是使能中断屏蔽器和失能.\n// 设置中断状态（PRIMASK寄存器）// 参数：status - 要设置的状态值（0启用中断，1禁用中断）INLINE void set_interrupt_state(status_reg_t status)&#123;    __asm__ __volatile__ (        &quot;MSR PRIMASK, %0\\n&quot;  // 内联汇编：将参数值写入PRIMASK寄存器        : : &quot;r&quot;(status)      // 输入操作数：将status变量放入通用寄存器        :&quot;memory&quot;            // 破坏描述：指示内存可能被修改    );&#125;// 获取当前中断状态（PRIMASK寄存器值）// 返回值：当前中断状态（0表示中断启用，1表示中断禁用）INLINE status_reg_t get_interrupt_state()&#123;    status_reg_t sr;    __asm__ __volatile__ (        &quot;MRS %0, PRIMASK&quot;    // 内联汇编：读取PRIMASK寄存器值        : &quot;=r&quot;(sr)           // 输出操作数：将结果存入sr变量    );    return sr;&#125;\n临界区包装器#if vortexRT_USER_DEFINED_CRITSECT_ENABLE == 0class TCritSect&#123;public:    INLINE TCritSect () : StatusReg(get_interrupt_state()) &#123; disable_interrupts(); &#125;    INLINE ~TCritSect() &#123; set_interrupt_state(StatusReg); &#125;private:    status_reg_t StatusReg;&#125;;#endif\n通过TCritSect进行临界区包装,为什么需要这种设计呢?其实是为了使用c++的RAII的特性,在类被创建时则自动调用构造函数,构造函数中调用关闭中断,销毁时调用析构函数,然后开启中断.这么设计的好处便是只要创建这个类,那么就会自动进入临界区和退出临界区,不会出现入后忘记退出.\nINLINE OS::TProcessMap get_prio_tag(const uint_fast8_t pr) &#123; return static_cast&lt;OS::TProcessMap&gt; (1 &lt;&lt; pr); &#125;#if vortexRT_PRIORITY_ORDER == 0    INLINE uint_fast8_t highest_priority(TProcessMap pm)    &#123;        extern TPriority const PriorityTable[];        #if vortexRT_PROCESS_COUNT &lt; 6            return PriorityTable[pm];        #else            uint32_t x = pm;            x = x &amp; -x;                             // Isolate rightmost 1-bit.                                                // x = x * 0x450FBAF            x = (x &lt;&lt; 4) | x;                       // x = x*17.            x = (x &lt;&lt; 6) | x;                       // x = x*65.            x = (x &lt;&lt; 16) - x;                      // x = x*65535.            return PriorityTable[x &gt;&gt; 26];        #endif  // vortexRT_PROCESS_COUNT &lt; 6    &#125;#else    INLINE uint_fast8_t highest_priority(TProcessMap pm)    &#123;        return 31 - __builtin_clz(pm);    &#125;#endif // vortexRT_PRIORITY_ORDER\n get_prio_tag将数字优先级转换为位掩码形式,供调度器快速进行优先级比较和查找与 highest_priority 函数配合实现高效调度.highest_priority 函数根据不同的处理器架构有两种实现方式：对于Cortex-M0等不支持CLZ指令的处理器，使用查表法结合巧妙的位操作来找到最高优先级,对于Cortex-M3&#x2F;M4等支持CLZ指令的处理器，直接使用31 - __builtin_clz(pm)这个高效的内建函数,在freertos中也能看到这样的写法.这种设计充分考虑了不同ARM架构的特性差异，在保证功能的同时最大化性能，是嵌入式RTOS优先级调度算法的经典实现。\n#if vortexRT_CONTEXT_SWITCH_SCHEME == 1// 触发PendSV异常以请求上下文切换// 直接操作NVIC中断控制状态寄存器(0xE000ED04)// 设置PENDSVSET位(第28位)来触发PendSV异常INLINE void raise_context_switch() &#123;     *((volatile uint32_t*)0xE000ED04) = 0x10000000;  // 0x10000000 = 1&lt;&lt;28&#125;// 启用嵌套中断的宏(空实现，默认已启用)#define ENABLE_NESTED_INTERRUPTS()// 根据配置决定是否禁用嵌套中断#if vortexRT_SYSTIMER_NEST_INTS_ENABLE == 0    // 通过临界区保护禁用嵌套中断    #define DISABLE_NESTED_INTERRUPTS() TCritSect cs#else    // 空实现，保持嵌套中断启用    #define DISABLE_NESTED_INTERRUPTS()#endif// 架构兼容性检查#else#error &quot;Cortex-M3 port supports software interrupt switch method only!&quot;#endif// 中断服务例程(ISR)包装器类// 用于管理中断嵌套计数和调度class TISRW&#123;public:    // 构造函数：进入ISR时自动调用    INLINE  TISRW()  &#123; ISR_Enter(); &#125;    // 析构函数：退出ISR时自动调用      INLINE  ~TISRW() &#123; ISR_Exit();  &#125;private:    //-----------------------------------------------------    // ISR进入处理    INLINE void ISR_Enter()    &#123;        TCritSect cs;  // 进入临界区保护        Kernel.ISR_NestCount++;  // 增加中断嵌套计数    &#125;    //-----------------------------------------------------    // ISR退出处理    INLINE void ISR_Exit()    &#123;        TCritSect cs;  // 进入临界区保护        if(--Kernel.ISR_NestCount) return;  // 减少嵌套计数，若非最外层中断则直接返回        Kernel.sched_isr();  // 最外层中断退出时触发调度    &#125;    //-----------------------------------------------------&#125;;// 定义TISRW_SS为TISRW的别名，保持向后兼容#define TISRW_SS    TISRW/* * 系统定时器中断处理函数 * 功能：处理系统定时器中断，更新内核计时并触发调度 */INLINE void system_timer_isr()&#123;    OS::TISRW ISR;  // 创建ISR包装器实例，自动管理嵌套计数#if vortexRT_SYSTIMER_NEST_INTS_ENABLE == 0    DISABLE_NESTED_INTERRUPTS();  // 根据配置禁用嵌套中断#endif#if vortexRT_SYSTIMER_HOOK_ENABLE == 1    system_timer_user_hook();  // 如果启用，调用用户定义的钩子函数#endif    Kernel.system_timer();  // 调用内核系统定时器处理&#125;\n函数具体实现再GitHub仓库：https://github.com/ruixuezhao890/vortexRT函数实现带有注释\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/05/18/rtos/vortexRT_8/","content":"","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"联通日记—1","url":"/2025/07/27/%E6%97%A5%E8%AE%B0/%E8%81%94%E9%80%9A%E6%97%A5%E8%AE%B0%E2%80%941/","content":"\n  10d79030e8222445804370796b90fca1d2aa4f99e8f5171f22f450be12c8bdd5\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n"}]