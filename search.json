[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的事件，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_1/","content":"VX.01 宏调控：条件编译实现内核模块化设计前言在正式开始介绍我的项目之前我先补充这个工程的一些信息。我是使用platformio插件进行开发的，编译工具使用的是gcc。可能有人会问这个插件不是用来开发arduino的嘛？有些片面了，arduino只是一个框架，其实也支持cmsis和cubemx等框架的开发，在这个工程中我选择的就是cubemx的框架开发，因为arduino框架封装的太多层，开发操作系统必定需要触及一些底层的函数。使用cubemx框架在这个插件下的开发体验是和早些年的标准库一样的体验，没有软件来生成初始化代码，都需要自己手动初始化。这对我而言无伤大雅，后续会移植到cubemx生成的工程下，现在的重点是方便编写内核，而不是开发。至于keil5，编译器不同若是有时间会实现对应的接口文件。在这个文章中只分析设计想法，具体实现再GitHub仓库中存有代码 链接：https://github.com/ruixuezhao890/vortexRT\n宏调控设计：三层配置体系操作系统一般的做法都是使用宏来配置内核的代码是否加入到编译的过程之中。这个内核也不例外，我是用三层配置体系来控制内核代码的编译分支，下面一一介绍。\n1.1 核心配置宏：必定选择\n此类宏对与内核来说是不可或缺的。如果缺少会导致出现二义性，导致编译器不知如何进行正确的编译，所以为了避免这种情况，采取了一些措施，如下：\n#ifndef vortexRT_PRIORITY_ORDER#error &quot;Error: Config macro vortexRT_PRIORITY_ORDER must be defined!&quot;#endif#if (vortexRT_PRIORITY_ORDER &lt; 0) || (vortexRT_PRIORITY_ORDER &gt; 1)#error &quot;Error: vortexRT_PRIORITY_ORDER must have values 0 or 1 only!&quot;#endif\n第一个判断的意思是vortexRT_PRIORITY_ORDER宏如果未定义，编译器会出现错误提醒，提醒的正是#error后面带的信息。 第二个判断的意思是检测vortexRT_PRIORITY_ORDER宏的取值范围如果不是0或1，编译器也会发出警告。\n通过这种方法，确保了宏必定会被定义并且也确保了值的正确，宏正确的实现了开关的效果。\n1.2功能可选宏：自由选择\n此类宏可以自由选择是否定义，如果没有定义则会使用默认值来进行编译控制，同样对宏的取值范围做了约束。具体如下图：\n#ifndef vortexRT_USER_DEFINED_CRITSECT_ENABLE#define vortexRT_USER_DEFINED_CRITSECT_ENABLE  0#endif#if (vortexRT_USER_DEFINED_CRITSECT_ENABLE &lt; 0) || (vortexRT_USER_DEFINED_CRITSECT_ENABLE &gt; 1)#error &quot;Error: vortexRT_USER_DEFINED_CRITSECT_ENABLE must have values 0 or 1 only!&quot;#endif\n上面的代码是控制是否使用用户自定义的临界区的宏，如果未定义则默认为0，所以一般是使用工程能自带的进入临界区的代码，如有特殊需要则可以使用这个宏来更改。取值前面已经说过不再赘述\n1.3调试宏与扩展宏：特殊功能的开关\nvortexRT_DEBUG_ENABLE: 调试模式开关vortexRT_PROCESS_RESTART_ENABLE: 进程重启功能开关类似上面这两种宏，拥有特殊功能方便使用者对内核的操作\n优先级设置可以设置优先级的高低顺序，以freeRTOS为例子，优先级数字越大，优先级越高。我希望这个内核可以控制优先级顺序通过宏vortexRT_PRIORITY_ORDER来控制到底是数字越大优先级越高还是反之。通过宏vortexRT_PROCESS_COUNT来控制线程数量，最大不能超过31，在这个范围内0-31任意多个线程可随意设定，总共最多32个线程。vortexRT_PRIORITY_ORDER为1时优先级数字越大，优先级越高，为0则反之。如下图\n#if vortexRT_PRIORITY_ORDER == 0        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        ...        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif            prIDLE#else   // vortexRT_PRIORITY_ORDER == 1    enum TPriority &#123;            prIDLE,        #if vortexRT_PROCESS_COUNT   &gt; 30            pr30,        #endif        ...        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0        #endif        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif    &#125;;#endif //vortexRT_PRIORITY_ORDER\n\n为了节省内存，还依照不同的最大线程个数，来控制不同的类型数据。\n#if vortexRT_PROCESS_COUNT &lt; 8    typedef uint_fast8_t TProcessMap;#elif vortexRT_PROCESS_COUNT &lt; 16    typedef uint_fast16_t TProcessMap;#else    typedef uint_fast32_t TProcessMap;#endif\n\n任务状态枚举定义enum TProcessStartState  &#123;      pssRunning,      pssSuspended  &#125;;\n相比与freeRTOS的就绪态、运行态、阻塞态和挂起态，本项目的却只有两种状态，为什么呢？\n仅设计运行(pssRunning)和挂起(pssSuspended)两种初始状态，这种精简设计针对嵌入式场景优化：运行状态直接进入调度队列，挂起状态需手动唤醒。牺牲了状态复杂度换取更少的内存占用和更高确定性，适合资源严格受限的单片机运行\n完整代码连接：https://github.com/ruixuezhao890/vortexRT/blob/main/core/vortexRT_defs.h\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/22/rtos/vortexRT_2/","content":"VX.02  内核设计：最重要的实现从这章开始进入内核的设计，应该会使用几篇内容来详细阐述是为何这么设计，会先从主要的几个内核类开始介绍，以及这些核心类如何协同工作，介绍完成之后在最后会补充剩余没有说明的函数或者是其余设计。逐步揭示进程管理、内存调度、中断处理等关键模块的设计奥秘，最后通过uml类图展现内核运转的全景视图。这些类都在os_kernel.h中声明\nTKernel类设计细节函数与变量补充// 声明操作系统启动函数，使用C语言链接规范// NORETURN 表示该函数不会返回（通常进入无限循环）// sp: 初始进程的栈指针extern &quot;C&quot; NORETURN void os_start(stack_item_t* sp);// 根据上下文切换方案选择不同的上下文切换函数声明#if vortexRT_CONTEXT_SWITCH_SCHEME == 0    // 方案0：直接上下文切换    // 声明上下文切换函数，使用C语言链接规范    // Curr_SP: 指向当前进程栈指针的指针（用于保存当前上下文）    // Next_SP: 下一个要切换进程的栈指针（用于恢复新上下文）    extern &quot;C&quot; void os_context_switcher(stack_item_t** Curr_SP, stack_item_t* Next_SP);#else    // 方案1：通过钩子函数进行上下文切换    // 声明上下文切换钩子函数，使用C语言链接规范    // sp: 当前栈指针    // 返回: 下一个要切换进程的栈指针    extern &quot;C&quot; stack_item_t* os_context_switch_hook(stack_item_t* sp);#endif // 定义系统中进程的总数，包括空闲进程(idle process)    // vortexRT_PROCESS_COUNT是用户配置的进程数，+1是包含系统空闲进程    const uint_fast8_t PROCESS_COUNT = vortexRT_PROCESS_COUNT + 1;        // 定义栈默认填充模式，用于检测栈溢出    // vortexRT_STACK_PATTERN是用户定义的栈填充值    const stack_item_t STACK_DEFAULT_PATTERN = vortexRT_STACK_PATTERN;        // 前向声明TBaseProcess类，因为后续函数声明中需要使用    class TBaseProcess;        // 设置优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;        // 设置优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;\n\n整体设计思想\n使用微内核架构：采用精简设计，只保留最核心的调度功能，其他的服务，例如：信号量或者互斥锁等作为外围模块支持，而不包含在这个类内。使这个类更为精简减少flash的占用。\n\n优先级调度：基于优先级的抢占式调度，内核不支持同优先级时间片流转，但是时间片流转会使用插件形式自行决定是否使用。最多支持32个优先级抢占MAX_PROCESS_COUNT\n\n中断管理：通过成员变量ISR_NestCount处理中断嵌套的场景，当ISR_NestCount大于0时禁止调度，最大支持255级中断嵌套。\n\n两种调度：两种上下文切换方案，通过宏开关进行选择。值 0 表示在调度器和操作系统中断服务程序（OS ISRs）中使用直接上下文切换，这是主要的方法。值 1 表示第二种上下文切换方式 —— 通过软件中断实现。根据资料显示Cortex-M 端口仅支持软件中断切换方法。\n\n\n类成员详细说明private:    uint_fast8_t CurProcPriority;          // 当前运行进程的优先级    volatile TProcessMap ReadyProcessMap;  // 就绪进程位图(volatile用于多线程/中断环境)    volatile uint_fast8_t ISR_NestCount;   // 中断嵌套计数器    private:    static TBaseProcess* ProcessTable[PROCESS_COUNT]; // 进程表，按优先级索引        #if vortexRT_CONTEXT_SWITCH_SCHEME == 1    volatile uint_fast8_t SchedProcPriority; // 调度进程优先级(方案1专用)    #endif    #if vortexRT_SYSTEM_TICKS_ENABLE == 1    volatile tick_count_t SysTickCount;     // 系统滴答计数器    #endif\n\n关键方法分析构造函数 \nINLINE TKernel()     : CurProcPriority(MAX_PROCESS_COUNT)  // 初始化为无效优先级表示OS未运行    , ReadyProcessMap((1ull &lt;&lt; PROCESS_COUNT) - 1) // 所有进程初始为就绪状态    , ISR_NestCount(0)  // 无中断嵌套&#123;&#125;\n\n进程管理\n// 注册进程到进程表INLINE static void register_process(TBaseProcess* const p);// 设置进程为就绪状态INLINE void set_process_ready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     set_prio_tag(ReadyProcessMap, PrioTag); &#125;// 设置进程为非就绪状态  INLINE void set_process_unready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     clr_prio_tag(ReadyProcessMap, PrioTag); &#125;\n调度器核心\n// 调度器核心实现void sched();// 调度器入口，检查中断嵌套情况INLINE void scheduler() &#123; if(ISR_NestCount) return; else sched(); &#125;// 中断服务例程专用的调度器INLINE void sched_isr();\n系统定时器\n// 系统定时器处理函数INLINE void system_timer();\n\nvortexRT_CONTEXT_SWITCH_SCHEME为1时专用方法介绍\n  #if vortexRT_CONTEXT_SWITCH_SCHEME == 1// 上下文切换完成检查(方案1专用)INLINE bool is_context_switch_done();// 触发上下文切换(方案1专用)INLINE void raise_context_switch() &#123; OS::raise_context_switch(); &#125;#endif\n\n全局单例模式声明。为什么不使用c++的单例模式？\n因为嵌入式系统资源受限制，单例模式在c++的实现会触及到动态内存分配和其他的额外开销对于资源少的单片机可能无法接受。所以直接声明全局变量更加能接受与节省资源。而且单例模式的饿汉模式会让加载时机不够明确带来不确定行，全局变量会在main函数之前进行创建加载，时机明确。在c++中的单例模式使用一个函数进行访问，这增加了程序的执行事件，在内核中会多次调用该实例会造成性能损失。并且内核本就是唯一性的不再需要c++的单例模式来提供唯一实例保障机制\nextern TKernel Kernel;\n\n\n\n设计特点\n高效位图操作：使用位图ReadyProcessMap来管理进程状态，通过位状态来查早最高优先级进程。\nvolatile关键字：关键变量使用该关键字确保多线程&#x2F;中断环境下的正确访问不出现错误。\n通过宏开关支持不同的配置方案更加灵活，适配更多的可能。\n内联函数：简单函数使用内联让编译器对其进行优化，提高执行效率降低性能损失，增加实时性\n\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/23/rtos/vortexRT_3/","content":"VX.03 基础进程实现：并行基石依照查询得到的资料可以知道，操作系统可以分为返回独立栈和不返回独立栈，这两种各有优劣，我选择使用宏定义由用户来选择支持哪一种模式。下面我将分别阐述这两种模式的优点与何时使用哪一种模式。\n\n返回独立栈：返回独立栈例如线程栈、任务栈。独立栈的意思是每个任务或者线程都拥有独立的栈空间，用于保存任务执行时的局部变量和函数调用链还有上下文的信息。它切换任务时，内核会修改线程栈指针（PSP，这个指针是硬件定义的指针）切换到新的任务栈空间，确保任务之间的隔离性。避免任务间栈溢出互相干扰，提高系统稳定性。可根据任务需求灵活分配栈大小（例如FreeRTOS中动态分配堆内存作为任务栈） 高效上下文切换：仅需保存当前任务的寄存器状态到其独立栈中，无需处理其他任务的栈数据。 \n非独立返回栈：所有的任务都共享同一栈空间（主栈MSP），任务切换的时候直接在共享栈中保存和恢复上下文。无需切换栈指针，直接通过压栈和出栈来管理上下文，一般用于裸机程序或者简单的调度系统。可以节省内存，不用给每个任务分配独立栈空间，使用资源受限的单片机，但是任务或者中断嵌套调用可能会导致共享栈溢出，破坏其他任务或者系统数据。\n\n由于是第一次写内核，我选择非独立栈来完成这个设计，但是预留独立栈的接口，通过宏定义来进行选择\nTBaseProcess的设计思考整体设计思想TBaseProcess是进程&#x2F;任务管理的基类，采用优先级调度机制支持两种栈配置模式（独立与非独立栈）提供进程生命周期管理的方法，以及提供调试信息与性能分析，通过vortexRT_DEBUG_ENABLE来控制开启还是关闭。\n关键数据结构//向前声明两个类，声明变量的时候要用到，后面的篇章会说明功能  class TKernelAgent;  class TService;protected:        // 数据成员        stack_item_t* StackPointer;    // 当前栈指针        volatile timeout_t Timeout;    // 超时计数器(volatile用于多线程/中断环境)        const TPriority Priority;      // 进程优先级(常量)        #if vortexRT_DEBUG_ENABLE == 1        // 调试相关数据成员        TService* volatile WaitingFor; // 当前等待的服务(可能被中断修改)        const stack_item_t* const StackPool; // 栈池起始地址(常量指针)        const size_t StackSize;        // 栈大小(以stack_item_t为单位)        const char* Name;              // 进程名称        #if SEPARATE_RETURN_STACK == 1 //独立栈启用        const stack_item_t* const RStackPool; // 返回栈池起始地址        const size_t RStackSize;       // 返回栈大小        #endif    #endif // vortexRT_DEBUG_ENABLE        #if vortexRT_PROCESS_RESTART_ENABLE == 1   //默认为0        volatile TProcessMap* WaitingProcessMap; // 等待进程映射表(重启功能)    #endif        #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0 //默认取消挂起 ，之后会在TService中实现挂起恢复操作        static TProcessMap SuspendedProcessMap; // 挂起进程映射表(静态成员)依旧使用位操作来确立是否挂起    #endif\n进程管理的方法介绍主要提供以下的管理方法：\n\nsleep() -顾名思义使得进程状态进入休眠，不再被调度；\nwake_up() -看名字依旧知道，唤醒进程；\nforce_wake_up() -强制唤醒进程；\nis_sleeping()-查看进程是不是休眠状态；\nis_suspended() -查看进程是不是被挂起状态；sleep相当与freertos的delay函数的功能，将进程休眠让出cpu的使用权力，超过时间后自动唤醒，也可以在超时之前使用wake_up进行主动唤醒。force_wake_up强制唤醒，不会确认进程是否处于休眠状态，直接唤醒执行。普通的唤醒是线程安全的不会破坏系统的状态，但是强制唤醒可能会重复唤醒同一个进程并且破坏优先级调度逻辑，导致资源竞争。大部分情况下都建议使用wake_up,少数特殊场景使用强制唤醒，例如：系统初始化进程时，从不可恢复的错误的状态下恢复时，看门狗恢复死锁进程时等。\nreset_controls() -重置进程控制状态 通过宏vortexRT_PROCESS_RESTART_ENABLE来确定是否开启该函数的定义，默认是关闭的\n\n栈管理的两种模式\n非独立返回栈// 参数：        // StackPoolEnd - 栈池结束地址(栈顶)        // pr - 进程优先级        // exec - 进程执行函数指针        // (调试模式下可选参数)        // aStackPool - 栈池起始地址(用于调试)        // name - 进程名称(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                 TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                const char* name = nullptr                #endif                );\n独立返回栈//    参数：// Stack - 数据栈指针(栈顶地址)// RStack - 返回栈指针(栈顶地址) // exec - 进程执行函数指针// (调试模式下可选参数)// StackPool - 数据栈池起始地址(用于调试)// RStackPool - 返回栈池起始地址(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                stack_item_t* RStack,                TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                stack_item_t* aRStackPool,                const char* name = 0                #endif                );\n\n调试的支持说明当调试模式启用时，该类提供 栈的使用情况分析，进程名称标识，和等待服务追踪（WaitingFor 成员变量）\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/25/rtos/vortexRT_4/","content":"VX.04 用户进程创建接口实现：多模式创建线程上一篇说到支持不同的栈模式，所以供系统调用的进程类也要支持不同模式下的正确创建，但是在TBaseProcess中实现对不同的栈模式显得繁琐并且不好维护。所以通过宏开关来选择是栈独立还是非独立实现具体进程的实例化，并且通过继承来复用TBaseProcess中封装好的进程通用操作，减少代码的重复性。通过宏在编译期间就确定避免运行时开销。\nprocess用户调用类实现思路由于非独立栈与独立栈的相差不是很多，这里以非独立栈进行讲解，补充一些独立栈的不同之处不再过多赘述。设计想法：通过编译期间来确定进程的特性。例如：优先级，栈大小，初始化状态。所以设计这个类使用模板参数传递必要参数，在编译期间进行计算与确定。  为了避开动态内存分配，毕竟资源不足的单片机上是不足以支持这种使用方法的，所以使用静态数组管理栈空间，避免运行时内存的分配。分层架构设计继承TBaseProcess复用核心功能，并且派生类只用实现exec()函数即可，这就是线程执行函数。\n最后通过typdef来重命名一个空闲进程，通过全局单例实例化来进行实例化。\n非独立返回栈template&lt;TPriority pr, size_t stk_size, TProcessStartState pss = pssRunning&gt;       class process : public TBaseProcess       &#123;       public:           // 构造函数声明(使用INLINE_PROCESS_CTOR宏定义内联)           // 参数：           // name_str - 进程名称字符串指针(调试模式下使用)           INLINE_PROCESS_CTOR process( const char * name_str = nullptr );           // 进程执行函数声明(必须由派生类实现)           // 使用OS_PROCESS宏定义特殊属性           OS_PROCESS static void exec();       #if vortexRT_PROCESS_RESTART_ENABLE == 1           // 进程终止函数(当启用进程重启功能时有效)           // 用于安全终止并重置进程状态           INLINE void terminate();       #endif              private:           // 进程栈空间数组           // 大小根据模板参数stk_size计算(stack_item_t单位)           stack_item_t Stack[stk_size/sizeof(stack_item_t)];       &#125;;       // 进程模板类构造函数实现       template&lt;TPriority pr, size_t stk_size, TProcessStartState pss&gt;       OS::process&lt;pr, stk_size, pss&gt;::process( const char *           #if vortexRT_DEBUG_ENABLE == 1// 调试模式下使用进程名称           name_str           #endif           ) : TBaseProcess(&amp;Stack[stk_size / sizeof(stack_item_t)]// 栈顶地址                            , pr// 进程优先级                            , reinterpret_cast&lt;void (*)()&gt;(exec)// 执行函数指针转换                         #if vortexRT_DEBUG_ENABLE == 1// 调试模式下使用进程名称                            , Stack// 栈起始地址(调试)                            , name_str// 进程名称(调试)                         #endif                            )                  &#123;           #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0           // 如果进程启动状态为挂起(pssSuspended)           if ( pss == pssSuspended )               // 从全局挂起进程映射表中清除当前优先级标记               clr_prio_tag(SuspendedProcessMap, get_prio_tag(pr));           #endif       &#125;       #if vortexRT_PROCESS_RESTART_ENABLE == 1       // 进程终止函数实现       template&lt;TPriority pr, size_t stk_size, TProcessStartState pss&gt;       void OS::process&lt;pr, stk_size, pss&gt;::terminate()       &#123;           TCritSect cs;// 临界区保护(防止中断干扰)           // 重置进程控制状态(清除等待状态等)           reset_controls();           // 重新初始化栈帧(保持原有执行函数)           init_stack_frame( &amp;Stack[stk_size/sizeof(stack_item_t)]                            , reinterpret_cast&lt;void (*)()&gt;(exec)                         #if vortexRT_DEBUG_ENABLE == 1                             , Stack                         #endif                           );       &#125;       #endif // vortexRT_RESTART_ENABLE   // 定义系统空闲进程类型别名   // 使用最低优先级(prIDLE)和预定义的栈大小       typedef OS::process&lt;OS::prIDLE, vortexRT_IDLE_PROCESS_STACK_SIZE&gt; TIdleProc;\n独立栈的版本// 进程模板类定义(双栈版本)// 模板参数：// pr       - 进程优先级(TPriority枚举类型)// stk_size - 数据栈空间大小(字节数)// rstk_size - 返回栈空间大小(字节数)// pss      - 进程启动状态(默认pssRunning运行状态)template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss = pssRunning&gt;class process : public TBaseProcess &#123;public:    // 构造函数声明(使用INLINE_PROCESS_CTOR宏定义内联)    // 参数：    // name_str - 进程名称字符串指针(调试模式下使用)    INLINE_PROCESS_CTOR process(const char* name_str = 0);    // 进程执行函数声明(必须由派生类实现)    // 使用OS_PROCESS宏定义特殊属性    OS_PROCESS static void exec();#if vortexRT_PROCESS_RESTART_ENABLE == 1    // 进程终止函数(当启用进程重启功能时有效)    // 用于安全终止并重置进程状态    INLINE void terminate();#endifprivate:    // 进程数据栈空间数组    stack_item_t Stack[stk_size/sizeof(stack_item_t)];    // 进程返回栈空间数组    stack_item_t RStack[rstk_size/sizeof(stack_item_t)];&#125;;// 进程模板类构造函数实现template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss&gt;process&lt;pr, stk_size, rstk_size, pss&gt;::process(const char*    #if vortexRT_DEBUG_ENABLE == 1  // 调试模式下使用进程名称    name_str    #endif    ): TBaseProcess(&amp;Stack[stk_size / sizeof(stack_item_t)],  // 数据栈顶地址                   &amp;RStack[rstk_size/sizeof(stack_item_t)],  // 返回栈顶地址                   pr,                                       // 进程优先级                   reinterpret_cast&lt;void (*)()&gt;(exec)         // 执行函数指针转换                #if vortexRT_DEBUG_ENABLE == 1               // 调试模式参数                   , Stack                                   // 数据栈起始地址                   , RStack                                  // 返回栈起始地址                   , name_str                                // 进程名称                #endif                   )&#123;    #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0    // 如果进程启动状态为挂起(pssSuspended)    if (pss == pssSuspended) &#123;        // 从全局挂起进程映射表中清除当前优先级标记        clr_prio_tag(SuspendedProcessMap, get_prio_tag(pr));    &#125;    #endif&#125;#if vortexRT_PROCESS_RESTART_ENABLE == 1// 进程终止函数实现template&lt;TPriority pr, size_t stk_size, size_t rstk_size, TProcessStartState pss&gt;void OS::process&lt;pr, stk_size, rstk_size, pss&gt;::terminate()&#123;    TCritSect cs;  // 临界区保护(防止中断干扰)    // 重置进程控制状态(清除等待状态等)    reset_controls();    // 重新初始化双栈帧(保持原有执行函数)    init_stack_frame(&amp;Stack[stk_size/sizeof(stack_item_t)],                    &amp;RStack[rstk_size/sizeof(stack_item_t)],                    reinterpret_cast&lt;void (*)()&gt;(exec)                #if vortexRT_DEBUG_ENABLE == 1                    , Stack    // 调试模式下传递数据栈起始地址                    , RStack   // 调试模式下传递返回栈起始地址                #endif                    );&#125;#endif// 定义系统空闲进程类型别名(双栈版本)// 使用最低优先级(prIDLE)和预定义的双栈大小typedef OS::process&lt;OS::prIDLE,                    vortexRT_IDLE_PROCESS_DATA_STACK_SIZE,                   vortexRT_IDLE_PROCESS_RETURN_STACK_SIZE&gt; TIdleProc;\n\n最后通过实例化一个空闲进程\nextern TIdleProc IdleProc;\n\n可能有点疑惑为什么进程中是static来声明的exec函数，学过c++的朋友有疑惑，学习c++的时候学习到的明明是静态成员函数是整个类所共有的一个函数，通过类名来进行访问，无需实例化变量访问也可运行。那么这里的进程类为什么能做到每个进程都是各自独立的exec函数呢。其实学习过模板过后就能明白，模板类在进行模板参数传递的时候，其实依据传递的参数编译器会为这个类再生成一份class类，他们每个进程已经不算是同一个类了，所以static声明的exec函数也自然而然独立了，顺利完成线程隔离的任务。权衡代码膨胀与编写便利过后这种设计是可以接受的。\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/28/rtos/vortexRT_5/","content":"VX.05 内核代理模式：安全的赋予内核能力TKernelAgent类是内核代理类同时一个工具类，其中的所有方法都是static，主要的功能便是提供对内核关键功能的受控访问接口。封装了内核的核心功能，通过静态方法的方式给其他组件提供内核能力，保证内核内部数据不被直接访问，提高封装性防止被意外更改内核数据。通过protect继承限制只有内核相关的类才能使用这些功能。这个类主要就是为了其他组件能够调用内核服务，又能保持内核内部的实现封装性。\nclass TKernelAgent&#123;    // 获取当前运行进程对象指针    // 通过查询内核的进程表(ProcessTable)获取    INLINE static TBaseProcess * cur_proc() &#123; return Kernel.ProcessTable[cur_proc_priority()]; &#125;protected:    // 构造函数设为protected，限制只有派生类可以实例化    TKernelAgent() &#123; &#125;        // 获取当前运行进程的优先级(只读引用)    INLINE static uint_fast8_t const &amp; cur_proc_priority() &#123; return Kernel.CurProcPriority; &#125;        // 获取就绪进程位图(volatile引用，可能被中断修改)    INLINE static volatile TProcessMap &amp; ready_process_map() &#123; return Kernel.ReadyProcessMap; &#125;        // 获取当前进程的超时计数器(volatile引用)    INLINE static volatile timeout_t &amp; cur_proc_timeout() &#123; return cur_proc()-&gt;Timeout; &#125;        // 触发内核重新调度    INLINE static void reschedule() &#123; Kernel.scheduler(); &#125;    // 设置指定优先级进程为就绪状态    INLINE static void set_process_ready(const uint_fast8_t pr) &#123; Kernel.set_process_ready(pr); &#125;        // 设置指定优先级进程为非就绪状态      INLINE static void set_process_unready(const uint_fast8_t pr) &#123; Kernel.set_process_unready(pr); &#125;#if vortexRT_DEBUG_ENABLE == 1    // 调试模式下获取当前进程等待的服务对象    INLINE static TService * volatile &amp; cur_proc_waiting_for() &#123; return cur_proc()-&gt;WaitingFor; &#125;#endif#if vortexRT_PROCESS_RESTART_ENABLE == 1    // 进程重启功能启用时，获取当前进程的等待映射表    INLINE static volatile TProcessMap * &amp; cur_proc_waiting_map() &#123; return cur_proc()-&gt;WaitingProcessMap; &#125;#endif&#125;;","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/28/rtos/vortexRT_6/","content":"VX.06 系统对外接口现在实现最后的系统对外调用的函数接口，内核文件的设计就已经结束了，下一个篇章实现freeRTOS中的port文件，也就是对于不同的芯片架构和编译器实现不同的接口文件，这才是实现任务调度的关键文件，没有它则无法实现任务调度。\n对外调用接口这一节没啥好说的就是对之前的函数进行了一次封装，直接看代码中的注释能完全理解，不再赘述\n    // 系统运行函数（永不返回）    INLINE NORETURN void run();        // 检查操作系统是否正在运行    INLINE bool os_running();        // 锁定系统定时器（临界区保护）    INLINE void lock_system_timer()    &#123; TCritSect cs; LOCK_SYSTEM_TIMER();   &#125;        // 解锁系统定时器（临界区保护）      INLINE void unlock_system_timer()  &#123; TCritSect cs; UNLOCK_SYSTEM_TIMER(); &#125;        // 进程休眠函数（默认参数0表示无限期休眠）    INLINE void sleep(timeout_t t = 0) &#123; TBaseProcess::sleep(t); &#125;        // 根据优先级获取进程控制块指针    INLINE const TBaseProcess * get_proc(uint_fast8_t Prio) &#123; return Kernel.ProcessTable[Prio]; &#125;        //--------------------------------------------------------------------------#if vortexRT_SYSTEM_TICKS_ENABLE == 1#if vortexRT_SYSTEM_TICKS_ATOMIC == 1    // 原子方式获取系统滴答计数（无锁版本）    INLINE tick_count_t get_tick_count() &#123; return Kernel.SysTickCount; &#125;#else    // 获取系统滴答计数（带临界区保护）    INLINE tick_count_t get_tick_count() &#123; TCritSect cs; return Kernel.SysTickCount; &#125;#endif#endif // vortexRT_SYSTEM_TICKS_ENABLE#if vortexRT_TARGET_IDLE_HOOK_ENABLE == 1    // 目标平台特定的空闲进程钩子函数    void idle_process_target_hook();#endif // vortexRT_TARGET_IDLE_HOOK_ENABLE#if vortexRT_SYSTIMER_HOOK_ENABLE == 1    // 系统定时器钩子函数（必须启用才能使用时间片轮转）    INLINE_SYS_TIMER_HOOK void system_timer_user_hook();#endif // vortexRT_SYSTIMER_HOOK_ENABLE#if vortexRT_CONTEXT_SWITCH_USER_HOOK_ENABLE == 1    // 上下文切换用户钩子函数（用于自定义上下文切换逻辑）    INLINE_CONTEXT_SWITCH_HOOK void context_switch_user_hook();#endif // vortexRT_CONTEXT_SWITCH_USER_HOOK_ENABLE#if vortexRT_IDLE_HOOK_ENABLE == 1    // 空闲进程用户钩子函数（用于自定义空闲任务处理）    void idle_process_user_hook();#endif // vortexRT_IDLE_HOOK_ENABLE","categories":["嵌入式"],"tags":["rtos","vortexRT"]}]