[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的事件，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_1/","content":"VX.01 宏调控：条件编译实现内核模块化设计前言在正式开始介绍我的项目之前我先补充这个工程的一些信息。我是使用platformio插件进行开发的，编译工具使用的是gcc。可能有人会问这个插件不是用来开发arduino的嘛？有些片面了，arduino只是一个框架，其实也支持cmsis和cubemx等框架的开发，在这个工程中我选择的就是cubemx的框架开发，因为arduino框架封装的太多层，开发操作系统必定需要触及一些底层的函数。使用cubemx框架在这个插件下的开发体验是和早些年的标准库一样的体验，没有软件来生成初始化代码，都需要自己手动初始化。这对我而言无伤大雅，后续会移植到cubemx生成的工程下，现在的重点是方便编写内核，而不是开发。至于keil5，编译器不同若是有时间会实现对应的接口文件。\n宏调控设计：三层配置体系操作系统一般的做法都是使用宏来配置内核的代码是否加入到编译的过程之中。这个内核也不例外，我是用三层配置体系来控制内核代码的编译分支，下面一一介绍。\n1.1 核心配置宏：必定选择\n此类宏对与内核来说是不可或缺的。如果缺少会导致出现二义性，导致编译器不知如何进行正确的编译，所以为了避免这种情况，采取了一些措施，如下：\n#ifndef vortexRT_PRIORITY_ORDER#error &quot;Error: Config macro vortexRT_PRIORITY_ORDER must be defined!&quot;#endif#if (vortexRT_PRIORITY_ORDER &lt; 0) || (vortexRT_PRIORITY_ORDER &gt; 1)#error &quot;Error: vortexRT_PRIORITY_ORDER must have values 0 or 1 only!&quot;#endif\n第一个判断的意思是vortexRT_PRIORITY_ORDER宏如果未定义，编译器会出现错误提醒，提醒的正是#error后面带的信息。 第二个判断的意思是检测vortexRT_PRIORITY_ORDER宏的取值范围如果不是0或1，编译器也会发出警告。\n通过这种方法，确保了宏必定会被定义并且也确保了值的正确，宏正确的实现了开关的效果。\n1.2功能可选宏：自由选择\n此类宏可以自由选择是否定义，如果没有定义则会使用默认值来进行编译控制，同样对宏的取值范围做了约束。具体如下图：\n#ifndef vortexRT_USER_DEFINED_CRITSECT_ENABLE#define vortexRT_USER_DEFINED_CRITSECT_ENABLE  0#endif#if (vortexRT_USER_DEFINED_CRITSECT_ENABLE &lt; 0) || (vortexRT_USER_DEFINED_CRITSECT_ENABLE &gt; 1)#error &quot;Error: vortexRT_USER_DEFINED_CRITSECT_ENABLE must have values 0 or 1 only!&quot;#endif\n上面的代码是控制是否使用用户自定义的临界区的宏，如果未定义则默认为0，所以一般是使用工程能自带的进入临界区的代码，如有特殊需要则可以使用这个宏来更改。取值前面已经说过不再赘述\n1.3调试宏与扩展宏：特殊功能的开关\nvortexRT_DEBUG_ENABLE: 调试模式开关vortexRT_PROCESS_RESTART_ENABLE: 进程重启功能开关类似上面这两种宏，拥有特殊功能方便使用者对内核的操作\n优先级设置可以设置优先级的高低顺序，以freeRTOS为例子，优先级数字越大，优先级越高。我希望这个内核可以控制优先级顺序通过宏vortexRT_PRIORITY_ORDER来控制到底是数字越大优先级越高还是反之。通过宏vortexRT_PROCESS_COUNT来控制线程数量，最大不能超过31，在这个范围内0-31任意多个线程可随意设定，总共最多32个线程。vortexRT_PRIORITY_ORDER为1时优先级数字越大，优先级越高，为0则反之。如下图\n#if vortexRT_PRIORITY_ORDER == 0        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        ...        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif            prIDLE#else   // vortexRT_PRIORITY_ORDER == 1    enum TPriority &#123;            prIDLE,        #if vortexRT_PROCESS_COUNT   &gt; 30            pr30,        #endif        ...        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0        #endif        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif    &#125;;#endif //vortexRT_PRIORITY_ORDER\n\n为了节省内存，还依照不同的最大线程个数，来控制不同的类型数据。\n#if vortexRT_PROCESS_COUNT &lt; 8    typedef uint_fast8_t TProcessMap;#elif vortexRT_PROCESS_COUNT &lt; 16    typedef uint_fast16_t TProcessMap;#else    typedef uint_fast32_t TProcessMap;#endif\n\n任务状态枚举定义enum TProcessStartState  &#123;      pssRunning,      pssSuspended  &#125;;\n相比与freeRTOS的就绪态、运行态、阻塞态和挂起态，本项目的却只有两种状态，为什么呢？\n仅设计运行(pssRunning)和挂起(pssSuspended)两种初始状态，这种精简设计针对嵌入式场景优化：运行状态直接进入调度队列，挂起状态需手动唤醒。牺牲了状态复杂度换取更少的内存占用和更高确定性，适合资源严格受限的单片机运行\n完整代码连接：https://github.com/ruixuezhao890/vortexRT/blob/main/core/vortexRT_defs.h\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/22/rtos/vortexRT_2/","content":"VX.02  内核设计：最重要的实现从这章开始进入内核的设计，应该会使用几篇内容来详细阐述是为何这么设计，会先从主要的几个内核类开始介绍，以及这些核心类如何协同工作，介绍完成之后在最后会补充剩余没有说明的函数或者是其余设计。逐步揭示进程管理、内存调度、中断处理等关键模块的设计奥秘，最后通过uml类图展现内核运转的全景视图。这些类都在os_kernel.h中声明\nTKernel类设计细节整体设计思想\n使用微内核架构：采用精简设计，只保留最核心的调度功能，其他的服务，例如：信号量或者互斥锁等作为外围模块支持，而不包含在这个类内。使这个类更为精简减少flash的占用。\n\n优先级调度：基于优先级的抢占式调度，内核不支持同优先级时间片流转，但是时间片流转会使用插件形式自行决定是否使用。最多支持32个优先级抢占MAX_PROCESS_COUNT\n\n中断管理：通过成员变量ISR_NestCount处理中断嵌套的场景，当ISR_NestCount大于0时禁止调度，最大支持255级中断嵌套。\n\n两种调度：两种上下文切换方案，通过宏开关进行选择。值 0 表示在调度器和操作系统中断服务程序（OS ISRs）中使用直接上下文切换，这是主要的方法。值 1 表示第二种上下文切换方式 —— 通过软件中断实现。根据资料显示Cortex-M 端口仅支持软件中断切换方法。\n\n\n类成员详细说明private:    uint_fast8_t CurProcPriority;          // 当前运行进程的优先级    volatile TProcessMap ReadyProcessMap;  // 就绪进程位图(volatile用于多线程/中断环境)    volatile uint_fast8_t ISR_NestCount;   // 中断嵌套计数器    private:    static TBaseProcess* ProcessTable[PROCESS_COUNT]; // 进程表，按优先级索引        #if vortexRT_CONTEXT_SWITCH_SCHEME == 1    volatile uint_fast8_t SchedProcPriority; // 调度进程优先级(方案1专用)    #endif    #if vortexRT_SYSTEM_TICKS_ENABLE == 1    volatile tick_count_t SysTickCount;     // 系统滴答计数器    #endif\n\n关键方法分析构造函数 \nINLINE TKernel()     : CurProcPriority(MAX_PROCESS_COUNT)  // 初始化为无效优先级表示OS未运行    , ReadyProcessMap((1ul &lt;&lt; PROCESS_COUNT) - 1) // 所有进程初始为就绪状态    , ISR_NestCount(0)  // 无中断嵌套&#123;&#125;\n\n进程管理\n// 注册进程到进程表INLINE static void register_process(TBaseProcess* const p);// 设置进程为就绪状态INLINE void set_process_ready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     set_prio_tag(ReadyProcessMap, PrioTag); &#125;// 设置进程为非就绪状态  INLINE void set_process_unready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     clr_prio_tag(ReadyProcessMap, PrioTag); &#125;\n调度器核心\n// 调度器核心实现void sched();// 调度器入口，检查中断嵌套情况INLINE void scheduler() &#123; if(ISR_NestCount) return; else sched(); &#125;// 中断服务例程专用的调度器INLINE void sched_isr();\n系统定时器\n// 系统定时器处理函数INLINE void system_timer();\n\nvortexRT_CONTEXT_SWITCH_SCHEME为1时专用方法介绍\n  #if vortexRT_CONTEXT_SWITCH_SCHEME == 1// 上下文切换完成检查(方案1专用)INLINE bool is_context_switch_done();// 触发上下文切换(方案1专用)INLINE void raise_context_switch() &#123; OS::raise_context_switch(); &#125;#endif\n\n全局单例模式声明。为什么不使用c++的单例模式？\n因为嵌入式系统资源受限制，单例模式在c++的实现会触及到动态内存分配和其他的额外开销对于资源少的单片机可能无法接受。所以直接声明全局变量更加能接受与节省资源。而且单例模式的饿汉模式会让加载时机不够明确带来不确定行，全局变量会在main函数之前进行创建加载，时机明确。在c++中的单例模式使用一个函数进行访问，这增加了程序的执行事件，在内核中会多次调用该实例会造成性能损失。并且内核本就是唯一性的不再需要c++的单例模式来提供唯一实例保障机制\nextern TKernel Kernel;\n\n\n\n设计特点\n高效位图操作：使用位图ReadyProcessMap来管理进程状态，通过位状态来查早最高优先级进程。\nvolatile关键字：关键变量使用该关键字确保多线程&#x2F;中断环境下的正确访问不出现错误。\n通过宏开关支持不同的配置方案更加灵活，适配更多的可能。\n内联函数：简单函数使用内联让编译器对其进行优化，提高执行效率降低性能损失，增加实时性\n\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/23/rtos/vortexRT_3/","content":"VX.03 基础进程实现：并行基石依照查询得到的资料可以知道，操作系统可以分为返回独立栈和不返回独立栈，这两种各有优劣，我选择使用宏定义由用户来选择支持哪一种模式。下面我将分别阐述这两种模式的优点与何时使用哪一种模式。\n\n返回独立栈：返回独立栈例如线程栈、任务栈。独立栈的意思是每个任务或者线程都拥有独立的栈空间，用于保存任务执行时的局部变量和函数调用链还有上下文的信息。它切换任务时，内核会修改线程栈指针（PSP，这个指针是硬件定义的指针）切换到新的任务栈空间，确保任务之间的隔离性。\n非独立返回栈：\n\nTBaseProcess的设计思考整体设计思想","categories":["嵌入式"],"tags":["rtos","vortexRT"]}]