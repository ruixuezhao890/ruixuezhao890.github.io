[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的事件，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_1/","content":"VX.01 宏调控：条件编译实现内核模块化设计前言在正式开始介绍我的项目之前我先补充这个工程的一些信息。我是使用platformio插件进行开发的，编译工具使用的是gcc。可能有人会问这个插件不是用来开发arduino的嘛？有些片面了，arduino只是一个框架，其实也支持cmsis和cubemx等框架的开发，在这个工程中我选择的就是cubemx的框架开发，因为arduino框架封装的太多层，开发操作系统必定需要触及一些底层的函数。使用cubemx框架在这个插件下的开发体验是和早些年的标准库一样的体验，没有软件来生成初始化代码，都需要自己手动初始化。这对我而言无伤大雅，后续会移植到cubemx生成的工程下，现在的重点是方便编写内核，而不是开发。至于keil5，编译器不同若是有时间会实现对应的接口文件。\n宏调控设计：三层配置体系操作系统一般的做法都是使用宏来配置内核的代码是否加入到编译的过程之中。这个内核也不例外，我是用三层配置体系来控制内核代码的编译分支，下面一一介绍。\n1.1 核心配置宏：必定选择\n此类宏对与内核来说是不可或缺的。如果缺少会导致出现二义性，导致编译器不知如何进行正确的编译，所以为了避免这种情况，采取了一些措施，如下：\n#ifndef vortexRT_PRIORITY_ORDER#error &quot;Error: Config macro vortexRT_PRIORITY_ORDER must be defined!&quot;#endif#if (vortexRT_PRIORITY_ORDER &lt; 0) || (vortexRT_PRIORITY_ORDER &gt; 1)#error &quot;Error: vortexRT_PRIORITY_ORDER must have values 0 or 1 only!&quot;#endif\n第一个判断的意思是vortexRT_PRIORITY_ORDER宏如果未定义，编译器会出现错误提醒，提醒的正是#error后面带的信息。 第二个判断的意思是检测vortexRT_PRIORITY_ORDER宏的取值范围如果不是0或1，编译器也会发出警告。\n通过这种方法，确保了宏必定会被定义并且也确保了值的正确，宏正确的实现了开关的效果。\n1.2功能可选宏：自由选择\n此类宏可以自由选择是否定义，如果没有定义则会使用默认值来进行编译控制，同样对宏的取值范围做了约束。具体如下图：\n#ifndef vortexRT_USER_DEFINED_CRITSECT_ENABLE#define vortexRT_USER_DEFINED_CRITSECT_ENABLE  0#endif#if (vortexRT_USER_DEFINED_CRITSECT_ENABLE &lt; 0) || (vortexRT_USER_DEFINED_CRITSECT_ENABLE &gt; 1)#error &quot;Error: vortexRT_USER_DEFINED_CRITSECT_ENABLE must have values 0 or 1 only!&quot;#endif\n上面的代码是控制是否使用用户自定义的临界区的宏，如果未定义则默认为0，所以一般是使用工程能自带的进入临界区的代码，如有特殊需要则可以使用这个宏来更改。取值前面已经说过不再赘述\n1.3调试宏与扩展宏：特殊功能的开关\nvortexRT_DEBUG_ENABLE: 调试模式开关vortexRT_PROCESS_RESTART_ENABLE: 进程重启功能开关类似上面这两种宏，拥有特殊功能方便使用者对内核的操作\n优先级设置可以设置优先级的高低顺序，以freeRTOS为例子，优先级数字越大，优先级越高。我希望这个内核可以控制优先级顺序通过宏vortexRT_PRIORITY_ORDER来控制到底是数字越大优先级越高还是反之。通过宏vortexRT_PROCESS_COUNT来控制线程数量，最大不能超过31，在这个范围内0-31任意多个线程可随意设定，总共最多32个线程。vortexRT_PRIORITY_ORDER为1时优先级数字越大，优先级越高，为0则反之。如下图\n#if vortexRT_PRIORITY_ORDER == 0        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        ...        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif            prIDLE#else   // vortexRT_PRIORITY_ORDER == 1    enum TPriority &#123;            prIDLE,        #if vortexRT_PROCESS_COUNT   &gt; 30            pr30,        #endif        ...        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0        #endif        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif    &#125;;#endif //vortexRT_PRIORITY_ORDER\n\n为了节省内存，还依照不同的最大线程个数，来控制不同的类型数据。\n#if vortexRT_PROCESS_COUNT &lt; 8    typedef uint_fast8_t TProcessMap;#elif vortexRT_PROCESS_COUNT &lt; 16    typedef uint_fast16_t TProcessMap;#else    typedef uint_fast32_t TProcessMap;#endif\n\n任务状态枚举定义enum TProcessStartState  &#123;      pssRunning,      pssSuspended  &#125;;\n相比与freeRTOS的就绪态、运行态、阻塞态和挂起态，本项目的却只有两种状态，为什么呢？\n仅设计运行(pssRunning)和挂起(pssSuspended)两种初始状态，这种精简设计针对嵌入式场景优化：运行状态直接进入调度队列，挂起状态需手动唤醒。牺牲了状态复杂度换取更少的内存占用和更高确定性，适合资源严格受限的单片机运行\n完整代码连接：https://github.com/ruixuezhao890/vortexRT/blob/main/core/vortexRT_defs.h\n","categories":["嵌入式"],"tags":["rtos"]}]