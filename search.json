[{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_0/","content":"VX.00 嵌入式操作系统：为什么要写一个内核何时埋下要写一个嵌入式内核的种子最开始学习嵌入式的操作系统的时候，就已经对这种技术十分感兴趣，这种技术让只有一个内核的单片机能够在宏观上实现任务并行，但其实微观上任务还是串行。第一次使用操作系统实现并行时，观察到led灯与串口能够”并行”运行时，这种复杂的时间交织技术让我感受到了震撼。\n裸机开发的困境：前后台系统的局限在裸机上编程时，我们常常只是一个单线程，我们在while中处理所有的事件，如果我们需要响应一个及时的中断，则是在中断回调函数中设立标志位，然后再在主线程while循环中处理事件，但是这种做法有一个十分明显的弊端：如果在处理中断事件的执行函数之前有一个十分耗费事件的函数调用，那么中断事件的响应会变得延后，这与我们要的即使响应中断事件的初衷相悖。经常写单片机的同学肯定会说我直接把处理中断事件的执行函数放在中断回调函数中不就行了。我们如果这么做了会严重破坏系统实时性，导致高优先级中断被阻塞、共享资源竞争甚至栈溢出等问题。这如同在高速公路应急车道停车，不仅阻碍关键任务通行，还可能引发连环事故。 \n宏观并行的骗局：微观串行的现实学习过freeRTOS或者是国产的RTThred操作系统的想必都知道，操作系统是利用PendSV_Handler中断来进行任务切换，一般是在1ms进行一次任务切换，切换之前保存任务现场，将cpu中的相关的寄存器内的值进行保存，然后切换至另一个任务，加载另一个任务保存下来的cpu相关寄存器的值，这样我们就完成了现场保存与还原现场，还原现场之后还是进行串行执行。这种精妙的寄存器操作如同时钟齿轮的咬合，在1ms的时间片内完成线程的交替。虽然理论很丰满，但是如何实现确实一片空白，我们并不知道实现细节，只是知其然不知其所以然。这让我对这个技术只是拥有片面的认识。\n探究内核实现细节：技术进阶之路我们并不知道在保存cpu相关的寄存器时究竟是保存了哪些具体的寄存器、我们并不知道是如何保证1ms精确时间进行任务切换等问题，这些问题如果只是单纯的看书是没办法理解的，所以这就是为什么需要创建这个工程，来完成进阶之路。并且主流的操作系统基本都由c语言完成，我想使用c++来构建这个操作系统的内核，可能只会实现抢占任务切换，时间片流转可能后续以插件的形式来支持。本工程将会在stm32f407zgt6上完成。工程会参考freertos、µC&#x2F;OS-II、rtthread和scm等操作系统源码（天赋&amp;技术没到独立门户），希望我能顺利完成这个工程并且之后上述困惑能被解决。\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/21/rtos/vortexRT_1/","content":"VX.01 宏调控：条件编译实现内核模块化设计前言在正式开始介绍我的项目之前我先补充这个工程的一些信息。我是使用platformio插件进行开发的，编译工具使用的是gcc。可能有人会问这个插件不是用来开发arduino的嘛？有些片面了，arduino只是一个框架，其实也支持cmsis和cubemx等框架的开发，在这个工程中我选择的就是cubemx的框架开发，因为arduino框架封装的太多层，开发操作系统必定需要触及一些底层的函数。使用cubemx框架在这个插件下的开发体验是和早些年的标准库一样的体验，没有软件来生成初始化代码，都需要自己手动初始化。这对我而言无伤大雅，后续会移植到cubemx生成的工程下，现在的重点是方便编写内核，而不是开发。至于keil5，编译器不同若是有时间会实现对应的接口文件。\n宏调控设计：三层配置体系操作系统一般的做法都是使用宏来配置内核的代码是否加入到编译的过程之中。这个内核也不例外，我是用三层配置体系来控制内核代码的编译分支，下面一一介绍。\n1.1 核心配置宏：必定选择\n此类宏对与内核来说是不可或缺的。如果缺少会导致出现二义性，导致编译器不知如何进行正确的编译，所以为了避免这种情况，采取了一些措施，如下：\n#ifndef vortexRT_PRIORITY_ORDER#error &quot;Error: Config macro vortexRT_PRIORITY_ORDER must be defined!&quot;#endif#if (vortexRT_PRIORITY_ORDER &lt; 0) || (vortexRT_PRIORITY_ORDER &gt; 1)#error &quot;Error: vortexRT_PRIORITY_ORDER must have values 0 or 1 only!&quot;#endif\n第一个判断的意思是vortexRT_PRIORITY_ORDER宏如果未定义，编译器会出现错误提醒，提醒的正是#error后面带的信息。 第二个判断的意思是检测vortexRT_PRIORITY_ORDER宏的取值范围如果不是0或1，编译器也会发出警告。\n通过这种方法，确保了宏必定会被定义并且也确保了值的正确，宏正确的实现了开关的效果。\n1.2功能可选宏：自由选择\n此类宏可以自由选择是否定义，如果没有定义则会使用默认值来进行编译控制，同样对宏的取值范围做了约束。具体如下图：\n#ifndef vortexRT_USER_DEFINED_CRITSECT_ENABLE#define vortexRT_USER_DEFINED_CRITSECT_ENABLE  0#endif#if (vortexRT_USER_DEFINED_CRITSECT_ENABLE &lt; 0) || (vortexRT_USER_DEFINED_CRITSECT_ENABLE &gt; 1)#error &quot;Error: vortexRT_USER_DEFINED_CRITSECT_ENABLE must have values 0 or 1 only!&quot;#endif\n上面的代码是控制是否使用用户自定义的临界区的宏，如果未定义则默认为0，所以一般是使用工程能自带的进入临界区的代码，如有特殊需要则可以使用这个宏来更改。取值前面已经说过不再赘述\n1.3调试宏与扩展宏：特殊功能的开关\nvortexRT_DEBUG_ENABLE: 调试模式开关vortexRT_PROCESS_RESTART_ENABLE: 进程重启功能开关类似上面这两种宏，拥有特殊功能方便使用者对内核的操作\n优先级设置可以设置优先级的高低顺序，以freeRTOS为例子，优先级数字越大，优先级越高。我希望这个内核可以控制优先级顺序通过宏vortexRT_PRIORITY_ORDER来控制到底是数字越大优先级越高还是反之。通过宏vortexRT_PROCESS_COUNT来控制线程数量，最大不能超过31，在这个范围内0-31任意多个线程可随意设定，总共最多32个线程。vortexRT_PRIORITY_ORDER为1时优先级数字越大，优先级越高，为0则反之。如下图\n#if vortexRT_PRIORITY_ORDER == 0        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        ...        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif            prIDLE#else   // vortexRT_PRIORITY_ORDER == 1    enum TPriority &#123;            prIDLE,        #if vortexRT_PROCESS_COUNT   &gt; 30            pr30,        #endif        ...        #if vortexRT_PROCESS_COUNT   &gt; 1            pr1,        #endif        #if vortexRT_PROCESS_COUNT   &gt; 0            pr0        #endif        #if (vortexRT_PROCESS_COUNT   &gt; 31) || (vortexRT_PROCESS_COUNT   &lt; 1)            #error &quot;Invalid Process Count specification! Must be from 1 to 31.&quot;        #endif    &#125;;#endif //vortexRT_PRIORITY_ORDER\n\n为了节省内存，还依照不同的最大线程个数，来控制不同的类型数据。\n#if vortexRT_PROCESS_COUNT &lt; 8    typedef uint_fast8_t TProcessMap;#elif vortexRT_PROCESS_COUNT &lt; 16    typedef uint_fast16_t TProcessMap;#else    typedef uint_fast32_t TProcessMap;#endif\n\n任务状态枚举定义enum TProcessStartState  &#123;      pssRunning,      pssSuspended  &#125;;\n相比与freeRTOS的就绪态、运行态、阻塞态和挂起态，本项目的却只有两种状态，为什么呢？\n仅设计运行(pssRunning)和挂起(pssSuspended)两种初始状态，这种精简设计针对嵌入式场景优化：运行状态直接进入调度队列，挂起状态需手动唤醒。牺牲了状态复杂度换取更少的内存占用和更高确定性，适合资源严格受限的单片机运行\n完整代码连接：https://github.com/ruixuezhao890/vortexRT/blob/main/core/vortexRT_defs.h\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/22/rtos/vortexRT_2/","content":"VX.02  内核设计：最重要的实现从这章开始进入内核的设计，应该会使用几篇内容来详细阐述是为何这么设计，会先从主要的几个内核类开始介绍，以及这些核心类如何协同工作，介绍完成之后在最后会补充剩余没有说明的函数或者是其余设计。逐步揭示进程管理、内存调度、中断处理等关键模块的设计奥秘，最后通过uml类图展现内核运转的全景视图。这些类都在os_kernel.h中声明\nTKernel类设计细节函数与变量补充// 声明操作系统启动函数，使用C语言链接规范// NORETURN 表示该函数不会返回（通常进入无限循环）// sp: 初始进程的栈指针extern &quot;C&quot; NORETURN void os_start(stack_item_t* sp);// 根据上下文切换方案选择不同的上下文切换函数声明#if vortexRT_CONTEXT_SWITCH_SCHEME == 0    // 方案0：直接上下文切换    // 声明上下文切换函数，使用C语言链接规范    // Curr_SP: 指向当前进程栈指针的指针（用于保存当前上下文）    // Next_SP: 下一个要切换进程的栈指针（用于恢复新上下文）    extern &quot;C&quot; void os_context_switcher(stack_item_t** Curr_SP, stack_item_t* Next_SP);#else    // 方案1：通过钩子函数进行上下文切换    // 声明上下文切换钩子函数，使用C语言链接规范    // sp: 当前栈指针    // 返回: 下一个要切换进程的栈指针    extern &quot;C&quot; stack_item_t* os_context_switch_hook(stack_item_t* sp);#endif // 定义系统中进程的总数，包括空闲进程(idle process)    // vortexRT_PROCESS_COUNT是用户配置的进程数，+1是包含系统空闲进程    const uint_fast8_t PROCESS_COUNT = vortexRT_PROCESS_COUNT + 1;        // 定义栈默认填充模式，用于检测栈溢出    // vortexRT_STACK_PATTERN是用户定义的栈填充值    const stack_item_t STACK_DEFAULT_PATTERN = vortexRT_STACK_PATTERN;        // 前向声明TBaseProcess类，因为后续函数声明中需要使用    class TBaseProcess;        // 设置优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(volatile版本)    // 用于在中断服务程序(ISR)中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(volatile TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;        // 设置优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要设置的优先级标记    INLINE void set_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm |= PrioTag; &#125;        // 清除优先级标记(非volatile版本)    // 用于在普通代码中修改进程就绪映射表    // pm: 进程优先级映射表引用    // PrioTag: 要清除的优先级标记    INLINE void clr_prio_tag(TProcessMap &amp; pm, const TProcessMap PrioTag) &#123; pm &amp;= ~static_cast&lt;unsigned&gt;(PrioTag); &#125;\n\n整体设计思想\n使用微内核架构：采用精简设计，只保留最核心的调度功能，其他的服务，例如：信号量或者互斥锁等作为外围模块支持，而不包含在这个类内。使这个类更为精简减少flash的占用。\n\n优先级调度：基于优先级的抢占式调度，内核不支持同优先级时间片流转，但是时间片流转会使用插件形式自行决定是否使用。最多支持32个优先级抢占MAX_PROCESS_COUNT\n\n中断管理：通过成员变量ISR_NestCount处理中断嵌套的场景，当ISR_NestCount大于0时禁止调度，最大支持255级中断嵌套。\n\n两种调度：两种上下文切换方案，通过宏开关进行选择。值 0 表示在调度器和操作系统中断服务程序（OS ISRs）中使用直接上下文切换，这是主要的方法。值 1 表示第二种上下文切换方式 —— 通过软件中断实现。根据资料显示Cortex-M 端口仅支持软件中断切换方法。\n\n\n类成员详细说明private:    uint_fast8_t CurProcPriority;          // 当前运行进程的优先级    volatile TProcessMap ReadyProcessMap;  // 就绪进程位图(volatile用于多线程/中断环境)    volatile uint_fast8_t ISR_NestCount;   // 中断嵌套计数器    private:    static TBaseProcess* ProcessTable[PROCESS_COUNT]; // 进程表，按优先级索引        #if vortexRT_CONTEXT_SWITCH_SCHEME == 1    volatile uint_fast8_t SchedProcPriority; // 调度进程优先级(方案1专用)    #endif    #if vortexRT_SYSTEM_TICKS_ENABLE == 1    volatile tick_count_t SysTickCount;     // 系统滴答计数器    #endif\n\n关键方法分析构造函数 \nINLINE TKernel()     : CurProcPriority(MAX_PROCESS_COUNT)  // 初始化为无效优先级表示OS未运行    , ReadyProcessMap((1ull &lt;&lt; PROCESS_COUNT) - 1) // 所有进程初始为就绪状态    , ISR_NestCount(0)  // 无中断嵌套&#123;&#125;\n\n进程管理\n// 注册进程到进程表INLINE static void register_process(TBaseProcess* const p);// 设置进程为就绪状态INLINE void set_process_ready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     set_prio_tag(ReadyProcessMap, PrioTag); &#125;// 设置进程为非就绪状态  INLINE void set_process_unready(const uint_fast8_t pr) &#123;     TProcessMap PrioTag = get_prio_tag(pr);     clr_prio_tag(ReadyProcessMap, PrioTag); &#125;\n调度器核心\n// 调度器核心实现void sched();// 调度器入口，检查中断嵌套情况INLINE void scheduler() &#123; if(ISR_NestCount) return; else sched(); &#125;// 中断服务例程专用的调度器INLINE void sched_isr();\n系统定时器\n// 系统定时器处理函数INLINE void system_timer();\n\nvortexRT_CONTEXT_SWITCH_SCHEME为1时专用方法介绍\n  #if vortexRT_CONTEXT_SWITCH_SCHEME == 1// 上下文切换完成检查(方案1专用)INLINE bool is_context_switch_done();// 触发上下文切换(方案1专用)INLINE void raise_context_switch() &#123; OS::raise_context_switch(); &#125;#endif\n\n全局单例模式声明。为什么不使用c++的单例模式？\n因为嵌入式系统资源受限制，单例模式在c++的实现会触及到动态内存分配和其他的额外开销对于资源少的单片机可能无法接受。所以直接声明全局变量更加能接受与节省资源。而且单例模式的饿汉模式会让加载时机不够明确带来不确定行，全局变量会在main函数之前进行创建加载，时机明确。在c++中的单例模式使用一个函数进行访问，这增加了程序的执行事件，在内核中会多次调用该实例会造成性能损失。并且内核本就是唯一性的不再需要c++的单例模式来提供唯一实例保障机制\nextern TKernel Kernel;\n\n\n\n设计特点\n高效位图操作：使用位图ReadyProcessMap来管理进程状态，通过位状态来查早最高优先级进程。\nvolatile关键字：关键变量使用该关键字确保多线程&#x2F;中断环境下的正确访问不出现错误。\n通过宏开关支持不同的配置方案更加灵活，适配更多的可能。\n内联函数：简单函数使用内联让编译器对其进行优化，提高执行效率降低性能损失，增加实时性\n\n完整代码链接：vortexRT&#x2F;core&#x2F;os_kernel.h at main · ruixuezhao890&#x2F;vortexRT\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]},{"title":"「破茧计划」vortexRT操作系统开发全周期实录","url":"/2025/04/23/rtos/vortexRT_3/","content":"VX.03 基础进程实现：并行基石依照查询得到的资料可以知道，操作系统可以分为返回独立栈和不返回独立栈，这两种各有优劣，我选择使用宏定义由用户来选择支持哪一种模式。下面我将分别阐述这两种模式的优点与何时使用哪一种模式。\n\n返回独立栈：返回独立栈例如线程栈、任务栈。独立栈的意思是每个任务或者线程都拥有独立的栈空间，用于保存任务执行时的局部变量和函数调用链还有上下文的信息。它切换任务时，内核会修改线程栈指针（PSP，这个指针是硬件定义的指针）切换到新的任务栈空间，确保任务之间的隔离性。避免任务间栈溢出互相干扰，提高系统稳定性。可根据任务需求灵活分配栈大小（例如FreeRTOS中动态分配堆内存作为任务栈） 高效上下文切换：仅需保存当前任务的寄存器状态到其独立栈中，无需处理其他任务的栈数据。 \n非独立返回栈：所有的任务都共享同一栈空间（主栈MSP），任务切换的时候直接在共享栈中保存和恢复上下文。无需切换栈指针，直接通过压栈和出栈来管理上下文，一般用于裸机程序或者简单的调度系统。可以节省内存，不用给每个任务分配独立栈空间，使用资源受限的单片机，但是任务或者中断嵌套调用可能会导致共享栈溢出，破坏其他任务或者系统数据。\n\n由于是第一次写内核，我选择非独立栈来完成这个设计，但是预留独立栈的接口，通过宏定义来进行选择\nTBaseProcess的设计思考整体设计思想TBaseProcess是进程&#x2F;任务管理的基类，采用优先级调度机制支持两种栈配置模式（独立与非独立栈）提供进程生命周期管理的方法，以及提供调试信息与性能分析，通过vortexRT_DEBUG_ENABLE来控制开启还是关闭。\n关键数据结构//向前声明两个类，声明变量的时候要用到，后面的篇章会说明功能  class TKernelAgent;  class TService;protected:        // 数据成员        stack_item_t* StackPointer;    // 当前栈指针        volatile timeout_t Timeout;    // 超时计数器(volatile用于多线程/中断环境)        const TPriority Priority;      // 进程优先级(常量)        #if vortexRT_DEBUG_ENABLE == 1        // 调试相关数据成员        TService* volatile WaitingFor; // 当前等待的服务(可能被中断修改)        const stack_item_t* const StackPool; // 栈池起始地址(常量指针)        const size_t StackSize;        // 栈大小(以stack_item_t为单位)        const char* Name;              // 进程名称        #if SEPARATE_RETURN_STACK == 1 //独立栈启用        const stack_item_t* const RStackPool; // 返回栈池起始地址        const size_t RStackSize;       // 返回栈大小        #endif    #endif // vortexRT_DEBUG_ENABLE        #if vortexRT_PROCESS_RESTART_ENABLE == 1   //默认为0        volatile TProcessMap* WaitingProcessMap; // 等待进程映射表(重启功能)    #endif        #if vortexRT_SUSPENDED_PROCESS_ENABLE != 0 //默认取消挂起 ，之后会在TService中实现挂起恢复操作        static TProcessMap SuspendedProcessMap; // 挂起进程映射表(静态成员)依旧使用位操作来确立是否挂起    #endif\n进程管理的方法介绍主要提供以下的管理方法：\n\nsleep() -顾名思义使得进程状态进入休眠，不再被调度；\nwake_up() -看名字依旧知道，唤醒进程；\nforce_wake_up() -强制唤醒进程；\nis_sleeping()-查看进程是不是休眠状态；\nis_suspended() -查看进程是不是被挂起状态；sleep相当与freertos的delay函数的功能，将进程休眠让出cpu的使用权力，超过时间后自动唤醒，也可以在超时之前使用wake_up进行主动唤醒。force_wake_up强制唤醒，不会确认进程是否处于休眠状态，直接唤醒执行。普通的唤醒是线程安全的不会破坏系统的状态，但是强制唤醒可能会重复唤醒同一个进程并且破坏优先级调度逻辑，导致资源竞争。大部分情况下都建议使用wake_up,少数特殊场景使用强制唤醒，例如：系统初始化进程时，从不可恢复的错误的状态下恢复时，看门狗恢复死锁进程时等。\n\n栈管理的两种模式\n非独立返回栈// 参数：        // StackPoolEnd - 栈池结束地址(栈顶)        // pr - 进程优先级        // exec - 进程执行函数指针        // (调试模式下可选参数)        // aStackPool - 栈池起始地址(用于调试)        // name - 进程名称(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                 TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                const char* name = nullptr                #endif                );\n独立返回栈//    参数：// Stack - 数据栈指针(栈顶地址)// RStack - 返回栈指针(栈顶地址) // exec - 进程执行函数指针// (调试模式下可选参数)// StackPool - 数据栈池起始地址(用于调试)// RStackPool - 返回栈池起始地址(用于调试)        TBaseProcess(stack_item_t* StackPoolEnd,                stack_item_t* RStack,                TPriority pr,                void (*exec)(),                #if vortexRT_DEBUG_ENABLE == 1                stack_item_t* aStackPool,                stack_item_t* aRStackPool,                const char* name = 0                #endif                );\n\n调试的支持说明当调试模式启用时，该类提供 栈的使用情况分析，进程名称标识，和等待服务追踪（WaitingFor 成员变量）\n完整代码链接：\n","categories":["嵌入式"],"tags":["rtos","vortexRT"]}]